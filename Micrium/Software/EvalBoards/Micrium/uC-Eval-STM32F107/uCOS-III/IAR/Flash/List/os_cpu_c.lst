###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       28/Nov/2017  16:24:33
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\os_cpu_c.c
#    Command line =  
#        "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\os_cpu_c.c"
#        -D USE_STDPERIPH_DRIVER -lCN
#        "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List"
#        -o "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\IAR\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\crccheck\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\csnrprotocol\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAP_pragram\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\usart\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\ST\STM32\inc\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\CMSIS\CM3\CoreSupport\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List\os_cpu_c.lst
#    Object file  =  
#        F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj\os_cpu_c.o
#
###############################################################################

F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III - 副本\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\os_cpu_c.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-III
      4          *                                          The Real-Time Kernel
      5          *
      6          *
      7          *                           (c) Copyright 2009-2010; Micrium, Inc.; Weston, FL
      8          *                    All rights reserved.  Protected by international copyright laws.
      9          *
     10          *                                           ARM Cortex-M3 Port
     11          *
     12          * File    : OS_CPU_C.C
     13          * Version : V3.02.01
     14          * By      : JJL
     15          *           BAN
     16          *
     17          * LICENSING TERMS:
     18          * ---------------
     19          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     20          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     21          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     22          *           application/product.   We provide ALL the source code for your convenience and to help you 
     23          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     24          *           it commercially without paying a licensing fee.
     25          *
     26          *           Knowledge of the source code may NOT be used to develop a similar product.
     27          *
     28          *           Please help us continue to provide the embedded community with the finest software available.
     29          *           Your honesty is greatly appreciated.
     30          *
     31          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     32          *
     33          * For       : ARMv7M Cortex-M3
     34          * Mode      : Thumb2
     35          * Toolchain : IAR EWARM
     36          *********************************************************************************************************
     37          */
     38          
     39          #define   OS_CPU_GLOBALS
     40          #include  "includes.h"

   \                                 In section .bss, align 4
   \   __absolute CPU_STK *OS_CPU_ExceptStkBase
   \                     OS_CPU_ExceptStkBase:
   \   00000000                      DS8 4
     41          
     42          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     43          const  CPU_CHAR  *os_cpu_c__c = "$Id: $";
     44          #endif
     45          
     46          /*$PAGE*/
     47          /*
     48          *********************************************************************************************************
     49          *                                             INCLUDE FILES
     50          *********************************************************************************************************
     51          */
     52          
     53          #include  <os.h>
     54          
     55          /*
     56          *********************************************************************************************************
     57          *                                           IDLE TASK HOOK
     58          *
     59          * Description: This function is called by the idle task.  This hook has been added to allow you to do
     60          *              such things as STOP the CPU to conserve power.
     61          *
     62          * Arguments  : None.
     63          *
     64          * Note(s)    : None.
     65          *********************************************************************************************************
     66          */
     67          

   \                                 In section .text, align 2, keep-with-next
     68          void  OSIdleTaskHook (void)
     69          {
   \                     OSIdleTaskHook: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     70          #if OS_CFG_APP_HOOKS_EN > 0u
     71              if (OS_AppIdleTaskHookPtr != (OS_APP_HOOK_VOID)0) {
   \   00000002   0x....             LDR.N    R0,??DataTable11
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD002             BEQ.N    ??OSIdleTaskHook_0
     72                  (*OS_AppIdleTaskHookPtr)();
   \   0000000A   0x....             LDR.N    R0,??DataTable11
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x4780             BLX      R0
     73              }
     74          #endif
     75          }
   \                     ??OSIdleTaskHook_0: (+1)
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
     76          
     77          
     78          /*$PAGE*/
     79          /*
     80          *********************************************************************************************************
     81          *                                       OS INITIALIZATION HOOK
     82          *
     83          * Description: This function is called by OSInit() at the beginning of OSInit().
     84          *
     85          * Arguments  : None.
     86          *
     87          * Note(s)    : None.
     88          *********************************************************************************************************
     89          */
     90          

   \                                 In section .text, align 2, keep-with-next
     91          void  OSInitHook (void)
     92          {
     93              OS_CPU_ExceptStkBase = (CPU_STK *)(OSCfg_ISRStkBasePtr + OSCfg_ISRStkSize - 1u);
   \                     OSInitHook: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_1
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x....             LDR.N    R1,??DataTable11_2
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0xEB10 0x0081      ADDS     R0,R0,R1, LSL #+2
   \   0000000C   0x1F00             SUBS     R0,R0,#+4
   \   0000000E   0x....             LDR.N    R1,??DataTable11_3
   \   00000010   0x6008             STR      R0,[R1, #+0]
     94          }
   \   00000012   0x4770             BX       LR               ;; return
     95          
     96          
     97          /*$PAGE*/
     98          /*
     99          *********************************************************************************************************
    100          *                                         STATISTIC TASK HOOK
    101          *
    102          * Description: This function is called every second by uC/OS-III's statistics task.  This allows your
    103          *              application to add functionality to the statistics task.
    104          *
    105          * Arguments  : None.
    106          *
    107          * Note(s)    : None.
    108          *********************************************************************************************************
    109          */
    110          

   \                                 In section .text, align 2, keep-with-next
    111          void  OSStatTaskHook (void)
    112          {
   \                     OSStatTaskHook: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    113          #if OS_CFG_APP_HOOKS_EN > 0u
    114              if (OS_AppStatTaskHookPtr != (OS_APP_HOOK_VOID)0) {
   \   00000002   0x....             LDR.N    R0,??DataTable11_4
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD002             BEQ.N    ??OSStatTaskHook_0
    115                  (*OS_AppStatTaskHookPtr)();
   \   0000000A   0x....             LDR.N    R0,??DataTable11_4
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x4780             BLX      R0
    116              }
    117          #endif
    118          }
   \                     ??OSStatTaskHook_0: (+1)
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    119          
    120          
    121          /*$PAGE*/
    122          /*
    123          *********************************************************************************************************
    124          *                                          TASK CREATION HOOK
    125          *
    126          * Description: This function is called when a task is created.
    127          *
    128          * Arguments  : p_tcb        Pointer to the task control block of the task being created.
    129          *
    130          * Note(s)    : None.
    131          *********************************************************************************************************
    132          */
    133          

   \                                 In section .text, align 2, keep-with-next
    134          void  OSTaskCreateHook (OS_TCB  *p_tcb)
    135          {
   \                     OSTaskCreateHook: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    136          #if OS_CFG_APP_HOOKS_EN > 0u
    137              if (OS_AppTaskCreateHookPtr != (OS_APP_HOOK_TCB)0) {
   \   00000004   0x....             LDR.N    R0,??DataTable11_5
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??OSTaskCreateHook_0
    138                  (*OS_AppTaskCreateHookPtr)(p_tcb);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x....             LDR.N    R1,??DataTable11_5
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x4788             BLX      R1
    139              }
    140          #else
    141              (void)p_tcb;                                            /* Prevent compiler warning                               */
    142          #endif
    143          }
   \                     ??OSTaskCreateHook_0: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    144          
    145          
    146          /*$PAGE*/
    147          /*
    148          *********************************************************************************************************
    149          *                                           TASK DELETION HOOK
    150          *
    151          * Description: This function is called when a task is deleted.
    152          *
    153          * Arguments  : p_tcb        Pointer to the task control block of the task being deleted.
    154          *
    155          * Note(s)    : None.
    156          *********************************************************************************************************
    157          */
    158          

   \                                 In section .text, align 2, keep-with-next
    159          void  OSTaskDelHook (OS_TCB  *p_tcb)
    160          {
   \                     OSTaskDelHook: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    161          #if OS_CFG_APP_HOOKS_EN > 0u
    162              if (OS_AppTaskDelHookPtr != (OS_APP_HOOK_TCB)0) {
   \   00000004   0x....             LDR.N    R0,??DataTable11_6
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??OSTaskDelHook_0
    163                  (*OS_AppTaskDelHookPtr)(p_tcb);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x....             LDR.N    R1,??DataTable11_6
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x4788             BLX      R1
    164              }
    165          #else
    166              (void)p_tcb;                                            /* Prevent compiler warning                               */
    167          #endif
    168          }
   \                     ??OSTaskDelHook_0: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    169          
    170          
    171          /*$PAGE*/
    172          /*
    173          *********************************************************************************************************
    174          *                                            TASK RETURN HOOK
    175          *
    176          * Description: This function is called if a task accidentally returns.  In other words, a task should
    177          *              either be an infinite loop or delete itself when done.
    178          *
    179          * Arguments  : p_tcb        Pointer to the task control block of the task that is returning.
    180          *
    181          * Note(s)    : None.
    182          *********************************************************************************************************
    183          */
    184          

   \                                 In section .text, align 2, keep-with-next
    185          void  OSTaskReturnHook (OS_TCB  *p_tcb)
    186          {
   \                     OSTaskReturnHook: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    187          #if OS_CFG_APP_HOOKS_EN > 0u
    188              if (OS_AppTaskReturnHookPtr != (OS_APP_HOOK_TCB)0) {
   \   00000004   0x....             LDR.N    R0,??DataTable11_7
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??OSTaskReturnHook_0
    189                  (*OS_AppTaskReturnHookPtr)(p_tcb);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x....             LDR.N    R1,??DataTable11_7
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x4788             BLX      R1
    190              }
    191          #else
    192              (void)p_tcb;                                            /* Prevent compiler warning                               */
    193          #endif
    194          }
   \                     ??OSTaskReturnHook_0: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    195          
    196          
    197          /*$PAGE*/
    198          /*
    199          **********************************************************************************************************
    200          *                                       INITIALIZE A TASK'S STACK
    201          *
    202          * Description: This function is called by OS_Task_Create() or OSTaskCreateExt() to initialize the stack
    203          *              frame of the task being created. This function is highly processor specific.
    204          *
    205          * Arguments  : p_task       Pointer to the task entry point address.
    206          *
    207          *              p_arg        Pointer to a user supplied data area that will be passed to the task
    208          *                               when the task first executes.
    209          *
    210          *              p_stk_base   Pointer to the base address of the stack.
    211          *
    212          *              stk_size     Size of the stack, in number of CPU_STK elements.
    213          *
    214          *              opt          Options used to alter the behavior of OS_Task_StkInit().
    215          *                            (see OS.H for OS_TASK_OPT_xxx).
    216          *
    217          * Returns    : Always returns the location of the new top-of-stack' once the processor registers have
    218          *              been placed on the stack in the proper order.
    219          *
    220          * Note(s)    : 1) Interrupts are enabled when task starts executing.
    221          *
    222          *              2) All tasks run in Thread mode, using process stack.
    223          **********************************************************************************************************
    224          */
    225          

   \                                 In section .text, align 2, keep-with-next
    226          CPU_STK  *OSTaskStkInit (OS_TASK_PTR    p_task,
    227                                   void          *p_arg,
    228                                   CPU_STK       *p_stk_base,
    229                                   CPU_STK       *p_stk_limit,
    230                                   CPU_STK_SIZE   stk_size,
    231                                   OS_OPT         opt)
    232          {
   \                     OSTaskStkInit: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x9D03             LDR      R5,[SP, #+12]
    233              CPU_STK  *p_stk;
    234          
    235          
    236              (void)opt;                                              /* Prevent compiler warning                               */
    237          
    238              p_stk = &p_stk_base[stk_size];                          /* Load stack pointer                                     */
   \   00000006   0xEB12 0x0685      ADDS     R6,R2,R5, LSL #+2
   \   0000000A   0x0030             MOVS     R0,R6
    239                                                                      /* Registers stacked as if auto-saved on exception        */
    240              *--p_stk = (CPU_STK)0x01000000u;                        /* xPSR                                                   */
   \   0000000C   0x1F00             SUBS     R0,R0,#+4
   \   0000000E   0xF05F 0x7680      MOVS     R6,#+16777216
   \   00000012   0x6006             STR      R6,[R0, #+0]
    241              *--p_stk = (CPU_STK)p_task;                             /* Entry Point                                            */
   \   00000014   0x1F00             SUBS     R0,R0,#+4
   \   00000016   0x6004             STR      R4,[R0, #+0]
    242              *--p_stk = (CPU_STK)OS_TaskReturn;                      /* R14 (LR)                                               */
   \   00000018   0x1F00             SUBS     R0,R0,#+4
   \   0000001A   0x....             LDR.N    R6,??DataTable11_8
   \   0000001C   0x6006             STR      R6,[R0, #+0]
    243              *--p_stk = (CPU_STK)0x12121212u;                        /* R12                                                    */
   \   0000001E   0x1F00             SUBS     R0,R0,#+4
   \   00000020   0xF05F 0x3612      MOVS     R6,#+303174162
   \   00000024   0x6006             STR      R6,[R0, #+0]
    244              *--p_stk = (CPU_STK)0x03030303u;                        /* R3                                                     */
   \   00000026   0x1F00             SUBS     R0,R0,#+4
   \   00000028   0xF05F 0x3603      MOVS     R6,#+50529027
   \   0000002C   0x6006             STR      R6,[R0, #+0]
    245              *--p_stk = (CPU_STK)0x02020202u;                        /* R2                                                     */
   \   0000002E   0x1F00             SUBS     R0,R0,#+4
   \   00000030   0xF05F 0x3602      MOVS     R6,#+33686018
   \   00000034   0x6006             STR      R6,[R0, #+0]
    246              *--p_stk = (CPU_STK)p_stk_limit;                        /* R1                                                     */
   \   00000036   0x1F00             SUBS     R0,R0,#+4
   \   00000038   0x6003             STR      R3,[R0, #+0]
    247              *--p_stk = (CPU_STK)p_arg;                              /* R0 : argument                                          */
   \   0000003A   0x1F00             SUBS     R0,R0,#+4
   \   0000003C   0x6001             STR      R1,[R0, #+0]
    248                                                                      /* Remaining registers saved on process stack             */
    249              *--p_stk = (CPU_STK)0x11111111u;                        /* R11                                                    */
   \   0000003E   0x1F00             SUBS     R0,R0,#+4
   \   00000040   0xF05F 0x3611      MOVS     R6,#+286331153
   \   00000044   0x6006             STR      R6,[R0, #+0]
    250              *--p_stk = (CPU_STK)0x10101010u;                        /* R10                                                    */
   \   00000046   0x1F00             SUBS     R0,R0,#+4
   \   00000048   0xF05F 0x3610      MOVS     R6,#+269488144
   \   0000004C   0x6006             STR      R6,[R0, #+0]
    251              *--p_stk = (CPU_STK)0x09090909u;                        /* R9                                                     */
   \   0000004E   0x1F00             SUBS     R0,R0,#+4
   \   00000050   0xF05F 0x3609      MOVS     R6,#+151587081
   \   00000054   0x6006             STR      R6,[R0, #+0]
    252              *--p_stk = (CPU_STK)0x08080808u;                        /* R8                                                     */
   \   00000056   0x1F00             SUBS     R0,R0,#+4
   \   00000058   0xF05F 0x3608      MOVS     R6,#+134744072
   \   0000005C   0x6006             STR      R6,[R0, #+0]
    253              *--p_stk = (CPU_STK)0x07070707u;                        /* R7                                                     */
   \   0000005E   0x1F00             SUBS     R0,R0,#+4
   \   00000060   0xF05F 0x3607      MOVS     R6,#+117901063
   \   00000064   0x6006             STR      R6,[R0, #+0]
    254              *--p_stk = (CPU_STK)0x06060606u;                        /* R6                                                     */
   \   00000066   0x1F00             SUBS     R0,R0,#+4
   \   00000068   0xF05F 0x3606      MOVS     R6,#+101058054
   \   0000006C   0x6006             STR      R6,[R0, #+0]
    255              *--p_stk = (CPU_STK)0x05050505u;                        /* R5                                                     */
   \   0000006E   0x1F00             SUBS     R0,R0,#+4
   \   00000070   0xF05F 0x3605      MOVS     R6,#+84215045
   \   00000074   0x6006             STR      R6,[R0, #+0]
    256              *--p_stk = (CPU_STK)0x04040404u;                        /* R4                                                     */
   \   00000076   0x1F00             SUBS     R0,R0,#+4
   \   00000078   0xF05F 0x3604      MOVS     R6,#+67372036
   \   0000007C   0x6006             STR      R6,[R0, #+0]
    257          
    258              return (p_stk);
   \   0000007E   0xBC70             POP      {R4-R6}
   \   00000080   0x4770             BX       LR               ;; return
    259          }
    260          
    261          
    262          /*$PAGE*/
    263          /*
    264          *********************************************************************************************************
    265          *                                           TASK SWITCH HOOK
    266          *
    267          * Description: This function is called when a task switch is performed.  This allows you to perform other
    268          *              operations during a context switch.
    269          *
    270          * Arguments  : None.
    271          *
    272          * Note(s)    : 1) Interrupts are disabled during this call.
    273          *              2) It is assumed that the global pointer 'OSTCBHighRdyPtr' points to the TCB of the task
    274          *                 that will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCurPtr' points
    275          *                 to the task being switched out (i.e. the preempted task).
    276          *********************************************************************************************************
    277          */
    278          

   \                                 In section .text, align 2, keep-with-next
    279          void  OSTaskSwHook (void)
    280          {
   \                     OSTaskSwHook: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    281          #if OS_CFG_TASK_PROFILE_EN > 0u
    282              CPU_TS  ts;
    283          #endif
    284          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    285              CPU_TS  int_dis_time;
    286          #endif
    287          
    288          
    289          
    290          #if OS_CFG_APP_HOOKS_EN > 0u
    291              if (OS_AppTaskSwHookPtr != (OS_APP_HOOK_VOID)0) {
   \   00000002   0x....             LDR.N    R0,??DataTable11_9
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD002             BEQ.N    ??OSTaskSwHook_0
    292                  (*OS_AppTaskSwHookPtr)();
   \   0000000A   0x....             LDR.N    R0,??DataTable11_9
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x4780             BLX      R0
    293              }
    294          #endif
    295          
    296          #if OS_CFG_TASK_PROFILE_EN > 0u
    297              ts = OS_TS_GET();
   \                     ??OSTaskSwHook_0: (+1)
   \   00000010   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000014   0x0004             MOVS     R4,R0
    298              if (OSTCBCurPtr != OSTCBHighRdyPtr) {
   \   00000016   0x....             LDR.N    R0,??DataTable11_10
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x....             LDR.N    R1,??DataTable11_11
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD015             BEQ.N    ??OSTaskSwHook_1
    299                  OSTCBCurPtr->CyclesDelta  = ts - OSTCBCurPtr->CyclesStart;
   \   00000022   0x....             LDR.N    R0,??DataTable11_10
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF8D0 0x0098      LDR      R0,[R0, #+152]
   \   0000002A   0x1A20             SUBS     R0,R4,R0
   \   0000002C   0x....             LDR.N    R1,??DataTable11_10
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0xF8C1 0x0094      STR      R0,[R1, #+148]
    300                  OSTCBCurPtr->CyclesTotal += (OS_CYCLES)OSTCBCurPtr->CyclesDelta;
   \   00000034   0x....             LDR.N    R0,??DataTable11_10
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF8D0 0x009C      LDR      R0,[R0, #+156]
   \   0000003C   0x....             LDR.N    R1,??DataTable11_10
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0xF8D1 0x1094      LDR      R1,[R1, #+148]
   \   00000044   0x1808             ADDS     R0,R1,R0
   \   00000046   0x....             LDR.N    R1,??DataTable11_10
   \   00000048   0x6809             LDR      R1,[R1, #+0]
   \   0000004A   0xF8C1 0x009C      STR      R0,[R1, #+156]
    301              }
    302          
    303              OSTCBHighRdyPtr->CyclesStart = ts;
   \                     ??OSTaskSwHook_1: (+1)
   \   0000004E   0x....             LDR.N    R0,??DataTable11_11
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF8C0 0x4098      STR      R4,[R0, #+152]
    304          #endif
    305          
    306          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    307              int_dis_time = CPU_IntDisMeasMaxCurReset();             /* Keep track of per-task interrupt disable time          */
   \   00000056   0x.... 0x....      BL       CPU_IntDisMeasMaxCurReset
   \   0000005A   0x0005             MOVS     R5,R0
    308              if (OSTCBCurPtr->IntDisTimeMax < int_dis_time) {
   \   0000005C   0x....             LDR.N    R0,??DataTable11_10
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF8D0 0x00B4      LDR      R0,[R0, #+180]
   \   00000064   0x42A8             CMP      R0,R5
   \   00000066   0xD203             BCS.N    ??OSTaskSwHook_2
    309                  OSTCBCurPtr->IntDisTimeMax = int_dis_time;
   \   00000068   0x....             LDR.N    R0,??DataTable11_10
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF8C0 0x50B4      STR      R5,[R0, #+180]
    310              }
    311          #endif
    312          
    313          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    314                                                                      /* Keep track of per-task scheduler lock time             */
    315              if (OSTCBCurPtr->SchedLockTimeMax < OSSchedLockTimeMaxCur) {
   \                     ??OSTaskSwHook_2: (+1)
   \   00000070   0x....             LDR.N    R0,??DataTable11_10
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0xF8D0 0x00B8      LDR      R0,[R0, #+184]
   \   00000078   0x....             LDR.N    R1,??DataTable11_12
   \   0000007A   0x6809             LDR      R1,[R1, #+0]
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xD205             BCS.N    ??OSTaskSwHook_3
    316                  OSTCBCurPtr->SchedLockTimeMax = OSSchedLockTimeMaxCur;
   \   00000080   0x....             LDR.N    R0,??DataTable11_12
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x....             LDR.N    R1,??DataTable11_10
   \   00000086   0x6809             LDR      R1,[R1, #+0]
   \   00000088   0xF8C1 0x00B8      STR      R0,[R1, #+184]
    317              }
    318              OSSchedLockTimeMaxCur = (CPU_TS)0;                      /* Reset the per-task value                               */
   \                     ??OSTaskSwHook_3: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x....             LDR.N    R1,??DataTable11_12
   \   00000090   0x6008             STR      R0,[R1, #+0]
    319          #endif
    320          }
   \   00000092   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    321          
    322          
    323          /*$PAGE*/
    324          /*
    325          *********************************************************************************************************
    326          *                                              TICK HOOK
    327          *
    328          * Description: This function is called every tick.
    329          *
    330          * Arguments  : None.
    331          *
    332          * Note(s)    : 1) This function is assumed to be called from the Tick ISR.
    333          *********************************************************************************************************
    334          */
    335          

   \                                 In section .text, align 2, keep-with-next
    336          void  OSTimeTickHook (void)
    337          {
   \                     OSTimeTickHook: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    338          #if OS_CFG_APP_HOOKS_EN > 0u
    339              if (OS_AppTimeTickHookPtr != (OS_APP_HOOK_VOID)0) {
   \   00000002   0x....             LDR.N    R0,??DataTable11_13
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD002             BEQ.N    ??OSTimeTickHook_0
    340                  (*OS_AppTimeTickHookPtr)();
   \   0000000A   0x....             LDR.N    R0,??DataTable11_13
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x4780             BLX      R0
    341              }
    342          #endif
    343          }
   \                     ??OSTimeTickHook_0: (+1)
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    344          
    345          
    346          /*$PAGE*/
    347          /*
    348          *********************************************************************************************************
    349          *                                          SYS TICK HANDLER
    350          *
    351          * Description: Handle the system tick (SysTick) interrupt, which is used to generate the uC/OS-II tick
    352          *              interrupt.
    353          *
    354          * Arguments  : None.
    355          *
    356          * Note(s)    : 1) This function MUST be placed on entry 15 of the Cortex-M3 vector table.
    357          *********************************************************************************************************
    358          */
    359          

   \                                 In section .bss, align 4
    360          int  g_systictimes = 0;
   \                     g_systictimes:
   \   00000000                      DS8 4
    361          
    362          

   \                                 In section .text, align 2, keep-with-next
    363          void  OS_CPU_SysTickHandler (void)
    364          {
    365              g_systictimes++;
   \                     OS_CPU_SysTickHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_14
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \   00000006   0x....             LDR.N    R1,??DataTable11_14
   \   00000008   0x6008             STR      R0,[R1, #+0]
    366          
    367          #ifdef  BOOTLOADER    
    368          #else
    369              CPU_SR_ALLOC();
    370              
    371              CPU_CRITICAL_ENTER();
    372              OSIntNestingCtr++;                                      /* Tell uC/OS-III that we are starting an ISR             */
    373              CPU_CRITICAL_EXIT();
    374          
    375              OSTimeTick();                                           /* Call uC/OS-III's OSTimeTick()                          */
    376          
    377              OSIntExit();                                            /* Tell uC/OS-III that we are leaving the ISR             */
    378          #endif    
    379          }
   \   0000000A   0x4770             BX       LR               ;; return
    380          

   \                                 In section .text, align 2, keep-with-next
    381          int  GetSysBaseTick(void)
    382          {
    383              return g_systictimes;
   \                     GetSysBaseTick: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_14
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    384          }
    385          
    386          
    387          /*$PAGE*/
    388          /*
    389          *********************************************************************************************************
    390          *                                         INITIALIZE SYS TICK
    391          *
    392          * Description: Initialize the SysTick.
    393          *
    394          * Arguments  : cnts         Number of SysTick counts between two OS tick interrupts.
    395          *
    396          * Note(s)    : 1) This function MUST be called after OSStart() & after processor initialization.
    397          *********************************************************************************************************
    398          */
    399          

   \                                 In section .text, align 2, keep-with-next
    400          void  OS_CPU_SysTickInit (CPU_INT32U  cnts)
    401          {
    402              CPU_INT32U  prio;
    403          
    404              CPU_REG_NVIC_ST_RELOAD = cnts - 1u;
   \                     OS_CPU_SysTickInit: (+1)
   \   00000000   0x1E42             SUBS     R2,R0,#+1
   \   00000002   0x....             LDR.N    R3,??DataTable11_15  ;; 0xe000e014
   \   00000004   0x601A             STR      R2,[R3, #+0]
    405                                                                      /* Set SysTick handler prio.                              */
    406              prio  = CPU_REG_NVIC_SHPRI3;
   \   00000006   0x....             LDR.N    R2,??DataTable11_16  ;; 0xe000ed20
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x0011             MOVS     R1,R2
    407              prio &= DEF_BIT_FIELD(24, 0);
   \   0000000C   0x0209             LSLS     R1,R1,#+8        ;; ZeroExtS R1,R1,#+8,#+8
   \   0000000E   0x0A09             LSRS     R1,R1,#+8
    408              prio |= DEF_BIT_MASK(OS_CPU_CFG_SYSTICK_PRIO, 24);
    409          
    410              CPU_REG_NVIC_SHPRI3 = prio;
   \   00000010   0x....             LDR.N    R2,??DataTable11_16  ;; 0xe000ed20
   \   00000012   0x6011             STR      R1,[R2, #+0]
    411                                                                      /* Enable timer.                                          */
    412              CPU_REG_NVIC_ST_CTRL |= CPU_REG_NVIC_ST_CTRL_CLKSOURCE |
    413                                      CPU_REG_NVIC_ST_CTRL_ENABLE;
   \   00000014   0x....             LDR.N    R2,??DataTable11_17  ;; 0xe000e010
   \   00000016   0x6812             LDR      R2,[R2, #+0]
   \   00000018   0xF052 0x0205      ORRS     R2,R2,#0x5
   \   0000001C   0x....             LDR.N    R3,??DataTable11_17  ;; 0xe000e010
   \   0000001E   0x601A             STR      R2,[R3, #+0]
    414                                                                      /* Enable timer interrupt.                                */
    415              CPU_REG_NVIC_ST_CTRL |= CPU_REG_NVIC_ST_CTRL_TICKINT;
   \   00000020   0x....             LDR.N    R2,??DataTable11_17  ;; 0xe000e010
   \   00000022   0x6812             LDR      R2,[R2, #+0]
   \   00000024   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   00000028   0x....             LDR.N    R3,??DataTable11_17  ;; 0xe000e010
   \   0000002A   0x601A             STR      R2,[R3, #+0]
    416          }
   \   0000002C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     OS_AppIdleTaskHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     OSCfg_ISRStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     OSCfg_ISRStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     OS_CPU_ExceptStkBase

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x........         DC32     OS_AppStatTaskHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     OS_AppTaskCreateHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x........         DC32     OS_AppTaskDelHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x........         DC32     OS_AppTaskReturnHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x........         DC32     OS_TaskReturn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x........         DC32     OS_AppTaskSwHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x........         DC32     OSTCBHighRdyPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x........         DC32     OSSchedLockTimeMaxCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   0x........         DC32     OS_AppTimeTickHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \   00000000   0x........         DC32     g_systictimes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \   00000000   0xE000E014         DC32     0xe000e014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \   00000000   0xE000ED20         DC32     0xe000ed20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_17:
   \   00000000   0xE000E010         DC32     0xe000e010
    417          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   GetSysBaseTick
       8   OSIdleTaskHook
         8   -- Indirect call
       0   OSInitHook
       8   OSStatTaskHook
         8   -- Indirect call
       8   OSTaskCreateHook
         8   -- Indirect call
       8   OSTaskDelHook
         8   -- Indirect call
       8   OSTaskReturnHook
         8   -- Indirect call
      12   OSTaskStkInit
      16   OSTaskSwHook
        16   -- Indirect call
        16   -> CPU_IntDisMeasMaxCurReset
        16   -> CPU_TS_TmrRd
       8   OSTimeTickHook
         8   -- Indirect call
       0   OS_CPU_SysTickHandler
       0   OS_CPU_SysTickInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       6  GetSysBaseTick
      18  OSIdleTaskHook
      20  OSInitHook
      18  OSStatTaskHook
      22  OSTaskCreateHook
      22  OSTaskDelHook
      22  OSTaskReturnHook
     130  OSTaskStkInit
     148  OSTaskSwHook
      18  OSTimeTickHook
       4  OS_CPU_ExceptStkBase
      12  OS_CPU_SysTickHandler
      46  OS_CPU_SysTickInit
       4  g_systictimes

 
   8 bytes in section .bss
 554 bytes in section .text
 
 554 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: none
