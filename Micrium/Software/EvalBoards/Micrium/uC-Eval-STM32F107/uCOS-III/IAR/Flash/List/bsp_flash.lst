###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       28/Nov/2017  16:24:32
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_flash.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_flash.c -D
#        USE_STDPERIPH_DRIVER -lCN "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List"
#        -o "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\IAR\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\crccheck\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\csnrprotocol\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAP_pragram\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\usart\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\ST\STM32\inc\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\CMSIS\CM3\CoreSupport\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List\bsp_flash.lst
#    Object file  =  
#        F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj\bsp_flash.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_flash.c
      1          /*******************************************************************************
      2           *   Filename:       bsp_flash.c
      3           *   Revised:        $Date: 2014-04-23
      4           *   Revision:       $
      5           *	 Writer:		 Wuming Shen.
      6           *
      7           *   Description:    
      8           *
      9           *   Notes:        
     10           *					   
     11           *			
     12           *   All copyrights reserved to Wuming Shen.
     13           *
     14           *******************************************************************************/
     15          
     16          #define BSP_FLASH_MODULE_EN 1
     17          #if BSP_FLASH_MODULE_EN > 0
     18          /*******************************************************************************
     19           * INCLUDES
     20           */
     21          #include "bsp_flash.h"
     22          #include  <stdio.h>
     23          #include  <string.h>
     24          #include  <ctype.h>
     25          #include  <stdlib.h>
     26          #include  <stdarg.h>
     27          

   \                                 In section .bss, align 4
     28          UnionFlashBuf   FlashBuf;
   \                     FlashBuf:
   \   00000000                      DS8 1024
     29          /*******************************************************************************
     30           * CONSTANTS
     31           */
     32          
     33          /*******************************************************************************
     34           * MACROS
     35           */
     36          
     37          /*******************************************************************************
     38           * TYPEDEFS
     39           */
     40          
     41          /*******************************************************************************
     42           * LOCAL VARIABLES
     43           */
     44          /***********************************************
     45          * 描述：
     46          */    
     47          
     48          /*******************************************************************************
     49           * GLOBAL VARIABLES
     50           */
     51          
     52          /*******************************************************************************
     53           * LOCAL FUNCTIONS
     54           */
     55          
     56          /*******************************************************************************
     57           * GLOBAL FUNCTIONS
     58           */
     59          
     60          /*******************************************************************************
     61           * EXTERN VARIABLES
     62           */
     63          
     64           /*******************************************************************************
     65           * EXTERN FUNCTIONS
     66           */
     67           
     68          /*******************************************************************************/
     69          
     70          
     71          /*******************************************************************************
     72           * 名    称： FlashReadHalfWord()
     73           * 功    能： 读取指定地址的16位数据
     74           * 入口参数：
     75           * 出口参数： 无
     76           * 作　　 者： 无名沈
     77           * 创建日期： 2014-04-23
     78           * 修    改： 
     79           * 修改日期： 
     80           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     81          u16  FlashReadHalfWord(u32 addr)
     82          {
     83          	return *(vu16 *)addr;
   \                     FlashReadHalfWord: (+1)
   \   00000000   0x8800             LDRH     R0,[R0, #+0]
   \   00000002   0x4770             BX       LR               ;; return
     84          }
     85          
     86          /*******************************************************************************
     87           * 名    称： BSP_FlashRead()
     88           * 功    能： 外部调用
     89           * 入口参数：
     90           * 出口参数： 无
     91           * 作　　 者： 无名沈
     92           * 创建日期： 2014-04-23
     93           * 修    改： 
     94           * 修改日期： 
     95           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     96          void  BSP_FlashRead(u32 addr,u16 *pbuffer,u16 num)   	
     97          {
   \                     BSP_FlashRead: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     98          	u16 i;
     99              
    100              FLASH_Unlock();                             // 解锁
   \   00000008   0x.... 0x....      BL       FLASH_Unlock
    101          	for(i = 0;i < num;i++) {
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0007             MOVS     R7,R0
   \                     ??BSP_FlashRead_0: (+1)
   \   00000010   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000012   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000014   0x42B7             CMP      R7,R6
   \   00000016   0xD207             BCS.N    ??BSP_FlashRead_1
    102          		*pbuffer++ = FlashReadHalfWord(addr);   //读取2个字节.
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       FlashReadHalfWord
   \   0000001E   0x8028             STRH     R0,[R5, #+0]
   \   00000020   0x1CAD             ADDS     R5,R5,#+2
    103          		addr += 2;                              //偏移2个字节.	
   \   00000022   0x1CA4             ADDS     R4,R4,#+2
    104          	}
   \   00000024   0x1C7F             ADDS     R7,R7,#+1
   \   00000026   0xE7F3             B.N      ??BSP_FlashRead_0
    105          	FLASH_Lock();             				    // 上锁
   \                     ??BSP_FlashRead_1: (+1)
   \   00000028   0x.... 0x....      BL       FLASH_Lock
    106          }
   \   0000002C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    107          
    108          /*******************************************************************************
    109           * 名    称： FlashRead()
    110           * 功    能： 
    111           * 入口参数：
    112           * 出口参数： 无
    113           * 作　　 者： 无名沈
    114           * 创建日期： 2014-04-23
    115           * 修    改： 
    116           * 修改日期： 
    117           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    118          void  FlashRead(u32 addr,u16 *pbuffer,u16 num)   	
    119          {
   \                     FlashRead: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    120          	u16 i;
    121              
    122          	for(i = 0;i < num;i++) {
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0007             MOVS     R7,R0
   \                     ??FlashRead_0: (+1)
   \   0000000C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000000E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000010   0x42B7             CMP      R7,R6
   \   00000012   0xD207             BCS.N    ??FlashRead_1
    123          		*pbuffer++ = FlashReadHalfWord(addr);   //读取2个字节.
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       FlashReadHalfWord
   \   0000001A   0x8028             STRH     R0,[R5, #+0]
   \   0000001C   0x1CAD             ADDS     R5,R5,#+2
    124          		addr += 2;                              //偏移2个字节.	
   \   0000001E   0x1CA4             ADDS     R4,R4,#+2
    125          	}
   \   00000020   0x1C7F             ADDS     R7,R7,#+1
   \   00000022   0xE7F3             B.N      ??FlashRead_0
    126          }
   \                     ??FlashRead_1: (+1)
   \   00000024   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    127          /*******************************************************************************
    128           * 名    称： FlashWriteNoCheck()
    129           * 功    能： 
    130           * 入口参数：
    131           * 出口参数： 无
    132           * 作　　 者： 无名沈
    133           * 创建日期： 2014-04-23
    134           * 修    改： 
    135           * 修改日期： 
    136           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    137          u8  FlashWriteNoCheck(u32 addr,u16 *pbuffer,u16 num)
    138          {
   \                     FlashWriteNoCheck: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    139          	u16 i;
    140              
    141          	for(i = 0;i < num;i++) {
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0007             MOVS     R7,R0
   \                     ??FlashWriteNoCheck_0: (+1)
   \   0000000C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000000E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000010   0x42B7             CMP      R7,R6
   \   00000012   0xD208             BCS.N    ??FlashWriteNoCheck_1
    142          		//if ( FLASH_COMPLETE != FLASH_ProgramHalfWord (addr,pbuffer[i]) ) {
    143                  //    return 0;
    144                  //}
    145                  FLASH_ProgramHalfWord (addr,pbuffer[i]);
   \   00000014   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000016   0xF835 0x1017      LDRH     R1,[R5, R7, LSL #+1]
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       FLASH_ProgramHalfWord
    146          		addr += 2;
   \   00000020   0x1CA4             ADDS     R4,R4,#+2
    147          	}
   \   00000022   0x1C7F             ADDS     R7,R7,#+1
   \   00000024   0xE7F2             B.N      ??FlashWriteNoCheck_0
    148              return 1;
   \                     ??FlashWriteNoCheck_1: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    149          }
    150          
    151          /*******************************************************************************
    152           * 名    称： FlashWrite()
    153           * 功    能： 带擦除的写
    154           * 入口参数：
    155           * 出口参数： 无
    156           * 作　　 者： 无名沈
    157           * 创建日期： 2014-04-23
    158           * 修    改： 
    159           * 修改日期： 
    160           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    161          void  BSP_FlashWrite(u32 addr,u16 *pbuffer,u16 num)
    162          {
   \                     BSP_FlashWrite: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    163          //	u16  num_sector;  						        // 在第几页
    164          //	u16  offset_sector;  					        // 在一页的偏移量
    165          //	u16  num_last;    						        // 剩下的半字
    166          //	u16  i;
    167          //	/***********************************************
    168          //    * 描述：
    169          //    */
    170          //    num_sector      = (addr - STM32_FLASH_BASE) / STM_SECTOR_SIZE;	   			// 获取第几页
    171          //	offset_sector   = ((addr - STM32_FLASH_BASE) % STM_SECTOR_SIZE) / 2;  	    // 获取偏移量，16个字节为单位
    172          //	num_last        = STM_SECTOR_SIZE / 2 - offset_sector;                     	// 求出剩下的半字
    173          //	
    174          //    FLASH_Unlock();                                 // 解锁
    175          //	/***********************************************
    176          //    * 描述：
    177          //    */
    178          //    if(num <= num_last)  
    179          //      num_last      = num;		                    // 可以一次写完
    180          //    /***********************************************
    181          //    * 描述：
    182          //    */
    183          //	for(;;)	{									        // 开始不停的写
    184          //		FlashRead(num_sector * STM_SECTOR_SIZE + STM32_FLASH_BASE,FlashBuf.buf2,STM_SECTOR_SIZE / 2);  // 读出一页
    185          //		for(i = 0;i < num_last;i++) {
    186          //			if(FlashBuf.buf2[offset_sector + i] != 0xffff) break;	
    187          //		}
    188          //		if(i < num_last) {						        // 需要擦除
    189          //			FLASH_ErasePage (num_sector * STM_SECTOR_SIZE + STM32_FLASH_BASE);  // 擦除
    190          //			for(i = 0;i < num_last;i++) {
    191          //				FlashBuf.buf2[offset_sector + i] = pbuffer[i];	                // 把要写入的数据填入数组
    192          //			}
    193          //			FlashWriteNoCheck(num_sector * STM_SECTOR_SIZE + STM32_FLASH_BASE,FlashBuf.buf2,STM_SECTOR_SIZE / 2);               //写整个扇区		
    194          //		} else {								        // 不需要擦除
    195          //			FlashWriteNoCheck(addr,pbuffer,num_last);	// 直接将要写入的数据写入flash
    196          //		}
    197          //        /***********************************************
    198          //        * 描述：
    199          //        */
    200          //		if(num_last == num) { 
    201          //            break;                                      // 写完后就跳出
    202          //		} else {                                        // 没有写完继续
    203          //			num_sector     += 1;    				    // 页加一
    204          //			offset_sector   = 0;  				        // 偏移为0
    205          //			pbuffer        += num_last;
    206          //			addr           += num_last * 2;
    207          //			num            -= num_last;    				// 调整要写入的数量
    208          //            
    209          //			if(num > (STM_SECTOR_SIZE / 2))  
    210          //                num_last = STM_SECTOR_SIZE / 2;
    211          //			else  
    212          //              num_last = num;   			            // 调整num_last		
    213          //		}		
    214          //	}
    215          //    
    216          //	FLASH_Lock();             					        // 上锁
    217              
    218          	u16  num_sector;                                    //在第几页
    219          	u16  offset_sector;                                 //在一页的偏移量
    220          	u16  num_last;                                      //剩下的半字
    221          	u16  i;
    222          	num_sector      =  (addr - STM32_FLASH_BASE) / STM_SECTOR_SIZE;	        //获取第几页
   \   0000000A   0x0AA0             LSRS     R0,R4,#+10
   \   0000000C   0x0007             MOVS     R7,R0
    223          	offset_sector   =  ((addr - STM32_FLASH_BASE) % STM_SECTOR_SIZE) / 2;   //获取偏移量，16个字节为单位
   \   0000000E   0xF1B4 0x6000      SUBS     R0,R4,#+134217728
   \   00000012   0xF44F 0x6180      MOV      R1,#+1024
   \   00000016   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   0000001A   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   0000001E   0x0850             LSRS     R0,R2,#+1
   \   00000020   0x4680             MOV      R8,R0
    224          	num_last        = 	STM_SECTOR_SIZE / 2 - offset_sector;                //求出剩下的半字
   \   00000022   0xF5D8 0x7000      RSBS     R0,R8,#+512
   \   00000026   0x4681             MOV      R9,R0
    225          	FLASH_Unlock();                                     //解锁
   \   00000028   0x.... 0x....      BL       FLASH_Unlock
    226          	if(num <= num_last)  num_last = num;		        //可以一次写完
   \   0000002C   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000030   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000032   0x45B1             CMP      R9,R6
   \   00000034   0xD300             BCC.N    ??BSP_FlashWrite_0
   \   00000036   0x46B1             MOV      R9,R6
    227          	
    228              for(;;)	{									        //开始不停的写
    229          		FlashRead(num_sector * STM_SECTOR_SIZE + STM32_FLASH_BASE,FlashBuf.buf2,STM_SECTOR_SIZE / 2);  //读出一页
   \                     ??BSP_FlashWrite_0: (+1)
   \   00000038   0xF44F 0x7200      MOV      R2,#+512
   \   0000003C   0x....             LDR.N    R1,??DataTable1
   \   0000003E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000040   0xF44F 0x6080      MOV      R0,#+1024
   \   00000044   0xFB00 0xF007      MUL      R0,R0,R7
   \   00000048   0xF110 0x6000      ADDS     R0,R0,#+134217728
   \   0000004C   0x.... 0x....      BL       FlashRead
    230          		for(i = 0;i < num_last;i++) {
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x4682             MOV      R10,R0
   \                     ??BSP_FlashWrite_1: (+1)
   \   00000054   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000058   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000005C   0x45CA             CMP      R10,R9
   \   0000005E   0xD20F             BCS.N    ??BSP_FlashWrite_2
    231          			if(FlashBuf.buf2[offset_sector + i] != 0xffff) break;	
   \   00000060   0x....             LDR.N    R0,??DataTable1
   \   00000062   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000066   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   0000006A   0xEB1A 0x0108      ADDS     R1,R10,R8
   \   0000006E   0xF830 0x0011      LDRH     R0,[R0, R1, LSL #+1]
   \   00000072   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000076   0x4288             CMP      R0,R1
   \   00000078   0xD102             BNE.N    ??BSP_FlashWrite_2
    232          		}
   \                     ??BSP_FlashWrite_3: (+1)
   \   0000007A   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   0000007E   0xE7E9             B.N      ??BSP_FlashWrite_1
    233          		if(i < num_last) { 					//需要擦除
   \                     ??BSP_FlashWrite_2: (+1)
   \   00000080   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000084   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000088   0x45CA             CMP      R10,R9
   \   0000008A   0xD22D             BCS.N    ??BSP_FlashWrite_4
    234          			FLASH_ErasePage (num_sector * STM_SECTOR_SIZE + STM32_FLASH_BASE);                      //擦除
   \   0000008C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000008E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000092   0xFB00 0xF007      MUL      R0,R0,R7
   \   00000096   0xF110 0x6000      ADDS     R0,R0,#+134217728
   \   0000009A   0x.... 0x....      BL       FLASH_ErasePage
    235          			for(i = 0;i < num_last;i++) {
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x4682             MOV      R10,R0
   \                     ??BSP_FlashWrite_5: (+1)
   \   000000A2   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000000A6   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000AA   0x45CA             CMP      R10,R9
   \   000000AC   0xD20F             BCS.N    ??BSP_FlashWrite_6
    236          				FlashBuf.buf2[offset_sector + i] = pbuffer[i];	               //把要写入的数据填入数组
   \   000000AE   0x....             LDR.N    R0,??DataTable1
   \   000000B0   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000B4   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000000B8   0xEB1A 0x0108      ADDS     R1,R10,R8
   \   000000BC   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000000C0   0xF835 0x201A      LDRH     R2,[R5, R10, LSL #+1]
   \   000000C4   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
    237          			}
   \   000000C8   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   000000CC   0xE7E9             B.N      ??BSP_FlashWrite_5
    238          			FlashWriteNoCheck(num_sector * STM_SECTOR_SIZE + STM32_FLASH_BASE,FlashBuf.buf2,STM_SECTOR_SIZE / 2);               //写整个扇区		
   \                     ??BSP_FlashWrite_6: (+1)
   \   000000CE   0xF44F 0x7200      MOV      R2,#+512
   \   000000D2   0x....             LDR.N    R1,??DataTable1
   \   000000D4   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000D6   0xF44F 0x6080      MOV      R0,#+1024
   \   000000DA   0xFB00 0xF007      MUL      R0,R0,R7
   \   000000DE   0xF110 0x6000      ADDS     R0,R0,#+134217728
   \   000000E2   0x.... 0x....      BL       FlashWriteNoCheck
   \   000000E6   0xE005             B.N      ??BSP_FlashWrite_7
    239          		} else {								    //不需要擦除
    240          		
    241          			FlashWriteNoCheck(addr,pbuffer,num_last);	//直接将要写入的数据写入flash
   \                     ??BSP_FlashWrite_4: (+1)
   \   000000E8   0x464A             MOV      R2,R9
   \   000000EA   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000EC   0x0029             MOVS     R1,R5
   \   000000EE   0x0020             MOVS     R0,R4
   \   000000F0   0x.... 0x....      BL       FlashWriteNoCheck
    242          		}
    243          		if(num_last == num)  
   \                     ??BSP_FlashWrite_7: (+1)
   \   000000F4   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000F8   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000FA   0x45B1             CMP      R9,R6
   \   000000FC   0xD102             BNE.N    ??BSP_FlashWrite_8
    244                      break;                                  //写完后就跳出
    245          		else  {                                     //没有写完继续
    246          			num_sector += 1;    //页加一
    247          			offset_sector = 0;  //偏移为0
    248          			pbuffer += num_last;
    249          			addr += num_last * 2;
    250          			num -= num_last;    //调整要写入的数量
    251          			if(num > (STM_SECTOR_SIZE / 2))  num_last = STM_SECTOR_SIZE / 2;
    252          			else  num_last = num;   //调整num_last		
    253          		}		
    254          	}
    255              
    256          	FLASH_Lock();             //上锁
   \   000000FE   0x.... 0x....      BL       FLASH_Lock
    257          }
   \   00000102   0xE016             B.N      ??BSP_FlashWrite_9
   \                     ??BSP_FlashWrite_8: (+1)
   \   00000104   0x1C7F             ADDS     R7,R7,#+1
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0x4680             MOV      R8,R0
   \   0000010A   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000010E   0xEB15 0x0549      ADDS     R5,R5,R9, LSL #+1
   \   00000112   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000116   0xEB14 0x0449      ADDS     R4,R4,R9, LSL #+1
   \   0000011A   0xEBB6 0x0609      SUBS     R6,R6,R9
   \   0000011E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000120   0xF5B6 0x7F00      CMP      R6,#+512
   \   00000124   0xDD03             BLE.N    ??BSP_FlashWrite_10
   \   00000126   0xF44F 0x7000      MOV      R0,#+512
   \   0000012A   0x4681             MOV      R9,R0
   \   0000012C   0xE784             B.N      ??BSP_FlashWrite_0
   \                     ??BSP_FlashWrite_10: (+1)
   \   0000012E   0x46B1             MOV      R9,R6
   \   00000130   0xE782             B.N      ??BSP_FlashWrite_0
   \                     ??BSP_FlashWrite_9: (+1)
   \   00000132   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    258          
    259          /*******************************************************************************
    260          * 名    称： BSP_FLASH_ReadPage
    261          * 功    能： 读一页数据，起始地址在页首
    262          * 入口参数： addr FLASH地址  pbuf ： 读取字节的数组 len : 数组的大小
    263          * 出口参数： 0（操作有误），1（操作成功）
    264          * 作　 　者： wumingshen
    265          * 创建日期： 2015-10-20
    266          * 修    改：
    267          * 修改日期：
    268          * 备    注：
    269          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    270          uint8_t BSP_FLASH_ReadPage( uint32_t addr , uint8_t *pbuf, u16 len )
    271          {
   \                     BSP_FLASH_ReadPage: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
    272              uint16_t    size   = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    273          
    274              if ( len > STM_SECTOR_SIZE )
   \   00000006   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000008   0xF5B2 0x6F80      CMP      R2,#+1024
   \   0000000C   0xDD01             BLE.N    ??BSP_FLASH_ReadPage_0
    275                return 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE00C             B.N      ??BSP_FLASH_ReadPage_1
    276          
    277              u16 *p      = (u16 *)pbuf;
   \                     ??BSP_FLASH_ReadPage_0: (+1)
   \   00000012   0x000D             MOVS     R5,R1
    278              
    279              for ( ; size < len ; size += 2 ) {
   \                     ??BSP_FLASH_ReadPage_2: (+1)
   \   00000014   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000016   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000018   0x4294             CMP      R4,R2
   \   0000001A   0xD205             BCS.N    ??BSP_FLASH_ReadPage_3
    280          		*p++     = *(vu16 *)addr;
   \   0000001C   0x8818             LDRH     R0,[R3, #+0]
   \   0000001E   0x8028             STRH     R0,[R5, #+0]
   \   00000020   0x1CAD             ADDS     R5,R5,#+2
    281          		addr    += 2;	
   \   00000022   0x1C9B             ADDS     R3,R3,#+2
    282          	}
   \   00000024   0x1CA4             ADDS     R4,R4,#+2
   \   00000026   0xE7F5             B.N      ??BSP_FLASH_ReadPage_2
    283              
    284              return size;
   \                     ??BSP_FLASH_ReadPage_3: (+1)
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??BSP_FLASH_ReadPage_1: (+1)
   \   0000002C   0xBC30             POP      {R4,R5}
   \   0000002E   0x4770             BX       LR               ;; return
    285          }
    286          
    287          /*******************************************************************************
    288          * 名    称： BSP_FLASH_WritePage
    289          * 功    能： 写一页数据，起始地址在页首
    290          * 入口参数： addr:  FLASH地址  pbuf: 写入字节的数组 len: 数组的大小
    291          * 出口参数： 0（操作有误），1（操作成功）
    292          * 作　 　者： wumingshen
    293          * 创建日期： 2015-10-20
    294          * 修    改：
    295          * 修改日期：
    296          * 备    注：
    297          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    298          uint8_t BSP_FLASH_WritePage( uint32_t addr , uint8_t *pbuf, u16 len )
    299          {
   \                     BSP_FLASH_WritePage: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    300              uint16_t    size   = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    301          
    302              if ( len > STM_SECTOR_SIZE )
   \   0000000C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000E   0xF5B6 0x6F80      CMP      R6,#+1024
   \   00000012   0xDD01             BLE.N    ??BSP_FLASH_WritePage_0
    303                return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE026             B.N      ??BSP_FLASH_WritePage_1
    304          
    305              u16 *p      = (u16 *)pbuf;
   \                     ??BSP_FLASH_WritePage_0: (+1)
   \   00000018   0x46A8             MOV      R8,R5
    306              s8  retrys;
    307              
    308              for ( ; size < len ; size += 2 ) {
   \                     ??BSP_FLASH_WritePage_2: (+1)
   \   0000001A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000001C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001E   0x42B7             CMP      R7,R6
   \   00000020   0xD21F             BCS.N    ??BSP_FLASH_WritePage_3
    309                  retrys  = 5;
   \   00000022   0x2005             MOVS     R0,#+5
   \   00000024   0x4681             MOV      R9,R0
    310                  do {
    311                      FLASH_ProgramHalfWord(addr,*(uint16_t *)p);
   \                     ??BSP_FLASH_WritePage_4: (+1)
   \   00000026   0xF8B8 0x1000      LDRH     R1,[R8, #+0]
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       FLASH_ProgramHalfWord
    312                      if (*(uint16_t *)addr == *(uint16_t *)p) {
   \   00000030   0x8820             LDRH     R0,[R4, #+0]
   \   00000032   0xF8B8 0x1000      LDRH     R1,[R8, #+0]
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD00E             BEQ.N    ??BSP_FLASH_WritePage_5
    313                          break;
    314                      } else if ( 1 == retrys ) {
   \                     ??BSP_FLASH_WritePage_6: (+1)
   \   0000003A   0xFA4F 0xF989      SXTB     R9,R9            ;; SignExt  R9,R9,#+24,#+24
   \   0000003E   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000042   0xD102             BNE.N    ??BSP_FLASH_WritePage_7
    315                          return size;
   \   00000044   0x0038             MOVS     R0,R7
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0xE00D             B.N      ??BSP_FLASH_WritePage_1
    316                      } 
    317                  } while ( --retrys );
   \                     ??BSP_FLASH_WritePage_7: (+1)
   \   0000004A   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   0000004E   0xFA4F 0xF989      SXTB     R9,R9            ;; SignExt  R9,R9,#+24,#+24
   \   00000052   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000056   0xD1E6             BNE.N    ??BSP_FLASH_WritePage_4
    318                  
    319          		addr    += 2;
   \                     ??BSP_FLASH_WritePage_5: (+1)
   \   00000058   0x1CA4             ADDS     R4,R4,#+2
    320                  p++;
   \   0000005A   0xF118 0x0802      ADDS     R8,R8,#+2
    321          	}
   \   0000005E   0x1CBF             ADDS     R7,R7,#+2
   \   00000060   0xE7DB             B.N      ??BSP_FLASH_WritePage_2
    322                      
    323              return size;
   \                     ??BSP_FLASH_WritePage_3: (+1)
   \   00000062   0x0038             MOVS     R0,R7
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??BSP_FLASH_WritePage_1: (+1)
   \   00000066   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    324          }
    325          
    326          /*******************************************************************************
    327          * 名    称： BSP_FlashWriteBytes
    328          * 功    能： 写多个字节
    329          * 入口参数： addr： FLASH地址  pbuf ：写入字节的数组 len : 数组的大小
    330          * 出口参数： 0（操作有误），1（操作成功）
    331          * 作　 　者： wumingshen
    332          * 创建日期： 2015-10-20
    333          * 修    改：
    334          * 修改日期：
    335          * 备    注：
    336          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    337          u16     BSP_FlashWriteBytes     (u32 addr, u8 *pbuf, u16 len)
    338          {
   \                     BSP_FlashWriteBytes: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0006             MOVS     R6,R0
   \   00000008   0x468B             MOV      R11,R1
   \   0000000A   0x4690             MOV      R8,R2
    339              uint16_t      bytes   = 0;
   \   0000000C   0x2700             MOVS     R7,#+0
    340              /***********************************************
    341              * 描述： 检测地址是否会溢出，如果溢出则直接返回
    342              */
    343              if ( (addr + len) > (FLASH_SIZE_EEP) )
   \   0000000E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000012   0xEB18 0x0006      ADDS     R0,R8,R6
   \   00000016   0xF5B0 0x4F80      CMP      R0,#+16384
   \   0000001A   0xD901             BLS.N    ??BSP_FlashWriteBytes_0
    344                  return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE0AE             B.N      ??BSP_FlashWriteBytes_1
    345          
    346              uint16_t    copyLen;                            // 要复制的长度
    347              uint32_t    pageAddr;
    348              uint16_t    size    = 0;                        // 一次写入长度
   \                     ??BSP_FlashWriteBytes_0: (+1)
   \   00000020   0xF05F 0x0900      MOVS     R9,#+0
    349              u32         page    = addr / STM_SECTOR_SIZE;   // 写入地址所在页（相对）
   \   00000024   0x0AB0             LSRS     R0,R6,#+10
   \   00000026   0x9000             STR      R0,[SP, #+0]
    350                          addr    += PARAM_START_ADDR;        // 转换成绝对地址
   \   00000028   0xF106 0x56BE      ADD      R6,R6,#+398458880
   \   0000002C   0xF516 0x167F      ADDS     R6,R6,#+4177920
    351              
    352          	FLASH_Unlock();             				    // 上锁
   \   00000030   0x.... 0x....      BL       FLASH_Unlock
    353              /***********************************************
    354              * 描述： 非页首开始，读取之前数据进行填充
    355              */
    356              if ( ( addr % STM_SECTOR_SIZE ) != 0 ) {
   \   00000034   0xF44F 0x6080      MOV      R0,#+1024
   \   00000038   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   0000003C   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD041             BEQ.N    ??BSP_FlashWriteBytes_2
    357                  size        = STM_SECTOR_SIZE - ( addr % STM_SECTOR_SIZE );
   \   00000044   0xF44F 0x6080      MOV      R0,#+1024
   \   00000048   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   0000004C   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   00000050   0xF5D1 0x6080      RSBS     R0,R1,#+1024
   \   00000054   0x4681             MOV      R9,R0
    358                  copyLen     = STM_SECTOR_SIZE - size;
   \   00000056   0xF5D9 0x6080      RSBS     R0,R9,#+1024
   \   0000005A   0x0004             MOVS     R4,R0
    359                  pageAddr    = PARAM_START_ADDR + page * STM_SECTOR_SIZE;
   \   0000005C   0x9800             LDR      R0,[SP, #+0]
   \   0000005E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000062   0x....             LDR.N    R2,??DataTable1_1  ;; 0x17ffc000
   \   00000064   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000068   0x0005             MOVS     R5,R0
    360                  // 读取当前页数据
    361                  BSP_FLASH_ReadPage(pageAddr, FlashBuf.buf1, STM_SECTOR_SIZE);
   \   0000006A   0xF44F 0x6280      MOV      R2,#+1024
   \   0000006E   0x....             LDR.N    R1,??DataTable1
   \   00000070   0x0028             MOVS     R0,R5
   \   00000072   0x.... 0x....      BL       BSP_FLASH_ReadPage
    362          
    363                  if ( size > len )
   \   00000076   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000007A   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000007E   0x45C8             CMP      R8,R9
   \   00000080   0xD200             BCS.N    ??BSP_FlashWriteBytes_3
    364                      size = len;
   \   00000082   0x46C1             MOV      R9,R8
    365                  // 复制属于当前页的数据到缓冲区中
    366                  memcpy(&FlashBuf.buf1[copyLen], pbuf, size);
   \                     ??BSP_FlashWriteBytes_3: (+1)
   \   00000084   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000088   0xF8CD 0xB004      STR      R11,[SP, #+4]
   \   0000008C   0x....             LDR.N    R0,??DataTable1
   \   0000008E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000090   0xEB14 0x0A00      ADDS     R10,R4,R0
   \   00000094   0x464A             MOV      R2,R9
   \   00000096   0x9901             LDR      R1,[SP, #+4]
   \   00000098   0x4650             MOV      R0,R10
   \   0000009A   0x.... 0x....      BL       __aeabi_memcpy
    367                  // 整页探险当前页
    368          		FLASH_ErasePage ( pageAddr );
   \   0000009E   0x0028             MOVS     R0,R5
   \   000000A0   0x.... 0x....      BL       FLASH_ErasePage
    369                  // 将缓冲区的数据写入当前页
    370                  BSP_FLASH_WritePage( pageAddr , FlashBuf.buf1 , STM_SECTOR_SIZE );
   \   000000A4   0xF44F 0x6280      MOV      R2,#+1024
   \   000000A8   0x....             LDR.N    R1,??DataTable1
   \   000000AA   0x0028             MOVS     R0,R5
   \   000000AC   0x.... 0x....      BL       BSP_FLASH_WritePage
    371                  // 源数据地址、写入地址、写入字节数增加size，未写数据长度减少size
    372                  addr    += size;
   \   000000B0   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000B4   0xEB19 0x0606      ADDS     R6,R9,R6
    373                  pbuf    += size;
   \   000000B8   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000BC   0xEB19 0x0B0B      ADDS     R11,R9,R11
    374                  bytes   += size;
   \   000000C0   0xEB19 0x0707      ADDS     R7,R9,R7
    375                  len     -= size;
   \   000000C4   0xEBB8 0x0809      SUBS     R8,R8,R9
    376              }
    377          
    378              /***********************************************
    379              * 描述： 页首开始，整页
    380              */
    381              size = len / STM_SECTOR_SIZE;
   \                     ??BSP_FlashWriteBytes_2: (+1)
   \   000000C8   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000CC   0xF44F 0x6080      MOV      R0,#+1024
   \   000000D0   0xFB98 0xF0F0      SDIV     R0,R8,R0
   \   000000D4   0x4681             MOV      R9,R0
    382              while ( size > 0 ) {
   \                     ??BSP_FlashWriteBytes_4: (+1)
   \   000000D6   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000DA   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000DE   0xD013             BEQ.N    ??BSP_FlashWriteBytes_5
    383                  // 探险当前页
    384          		FLASH_ErasePage (addr);
   \   000000E0   0x0030             MOVS     R0,R6
   \   000000E2   0x.... 0x....      BL       FLASH_ErasePage
    385                  // 写入当前数据页
    386                  BSP_FLASH_WritePage( addr , (u8 *)pbuf, STM_SECTOR_SIZE );
   \   000000E6   0xF44F 0x6280      MOV      R2,#+1024
   \   000000EA   0x4659             MOV      R1,R11
   \   000000EC   0x0030             MOVS     R0,R6
   \   000000EE   0x.... 0x....      BL       BSP_FLASH_WritePage
    387                  // 源数据地址、写入地址、写入字节数增加STM_SECTOR_SIZE，未写数据长度减少STM_SECTOR_SIZE
    388                  addr    += STM_SECTOR_SIZE;
   \   000000F2   0xF516 0x6680      ADDS     R6,R6,#+1024
    389                  pbuf    += STM_SECTOR_SIZE;
   \   000000F6   0xF51B 0x6B80      ADDS     R11,R11,#+1024
    390                  bytes   += STM_SECTOR_SIZE;
   \   000000FA   0xF517 0x6780      ADDS     R7,R7,#+1024
    391                  len     -= STM_SECTOR_SIZE;
   \   000000FE   0xF5B8 0x6880      SUBS     R8,R8,#+1024
    392                  // 页数减1
    393                  size    -= 1;
   \   00000102   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   00000106   0xE7E6             B.N      ??BSP_FlashWriteBytes_4
    394              }
    395          
    396              /***********************************************
    397              * 描述： 页首开始，不足一页
    398              */
    399              if ( len > 0 ) {
   \                     ??BSP_FlashWriteBytes_5: (+1)
   \   00000108   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000010C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000110   0xD031             BEQ.N    ??BSP_FlashWriteBytes_6
    400                  size        = STM_SECTOR_SIZE - ( addr % STM_SECTOR_SIZE );
   \   00000112   0xF44F 0x6080      MOV      R0,#+1024
   \   00000116   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   0000011A   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   0000011E   0xF5D1 0x6080      RSBS     R0,R1,#+1024
   \   00000122   0x4681             MOV      R9,R0
    401                  copyLen     = STM_SECTOR_SIZE - size;
   \   00000124   0xF5D9 0x6080      RSBS     R0,R9,#+1024
   \   00000128   0x0004             MOVS     R4,R0
    402                  pageAddr    = addr - copyLen;
   \   0000012A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000012C   0x1B30             SUBS     R0,R6,R4
   \   0000012E   0x0005             MOVS     R5,R0
    403                  
    404                  BSP_FLASH_ReadPage(pageAddr, FlashBuf.buf1, STM_SECTOR_SIZE);
   \   00000130   0xF44F 0x6280      MOV      R2,#+1024
   \   00000134   0x....             LDR.N    R1,??DataTable1
   \   00000136   0x0028             MOVS     R0,R5
   \   00000138   0x.... 0x....      BL       BSP_FLASH_ReadPage
    405          
    406                  if ( size > len )
   \   0000013C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000140   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000144   0x45C8             CMP      R8,R9
   \   00000146   0xD200             BCS.N    ??BSP_FlashWriteBytes_7
    407                      size = len;
   \   00000148   0x46C1             MOV      R9,R8
    408                  // 复制属于当前页的数据到缓冲区中
    409                  memcpy(&FlashBuf.buf1[copyLen],pbuf,size);
   \                     ??BSP_FlashWriteBytes_7: (+1)
   \   0000014A   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000014E   0x....             LDR.N    R0,??DataTable1
   \   00000150   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000152   0xEB14 0x0A00      ADDS     R10,R4,R0
   \   00000156   0x464A             MOV      R2,R9
   \   00000158   0x4659             MOV      R1,R11
   \   0000015A   0x4650             MOV      R0,R10
   \   0000015C   0x.... 0x....      BL       __aeabi_memcpy
    410          
    411                  // 整页探险当前页
    412          		FLASH_ErasePage (pageAddr);
   \   00000160   0x0028             MOVS     R0,R5
   \   00000162   0x.... 0x....      BL       FLASH_ErasePage
    413                  // 将缓冲区的数据写入当前页
    414                  BSP_FLASH_WritePage( pageAddr , (u8 *)FlashBuf.buf1 , STM_SECTOR_SIZE );
   \   00000166   0xF44F 0x6280      MOV      R2,#+1024
   \   0000016A   0x....             LDR.N    R1,??DataTable1
   \   0000016C   0x0028             MOVS     R0,R5
   \   0000016E   0x.... 0x....      BL       BSP_FLASH_WritePage
    415                  bytes   += len;
   \   00000172   0xEB18 0x0707      ADDS     R7,R8,R7
    416              }
    417          
    418          	FLASH_Lock();             				    // 上锁
   \                     ??BSP_FlashWriteBytes_6: (+1)
   \   00000176   0x.... 0x....      BL       FLASH_Lock
    419              return(bytes);
   \   0000017A   0x0038             MOVS     R0,R7
   \   0000017C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??BSP_FlashWriteBytes_1: (+1)
   \   0000017E   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    420          }
    421          
    422          /*******************************************************************************
    423          * 名    称： BSP_FlashReadBytes
    424          * 功    能： 读多个字节（必须是2的倍数）
    425          * 入口参数： addr： FLASH地址  pbuf ：写入字节的数组 len : 数组的大小（2的倍数）
    426          * 出口参数： 0（操作有误），1（操作成功）
    427          * 作　 　者： wumingshen
    428          * 创建日期： 2015-10-20
    429          * 修    改：
    430          * 修改日期：
    431          * 备    注：
    432          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    433          u16     BSP_FlashReadBytes      (u32 addr, u8 *pbuf, u16 len)
    434          { 
   \                     BSP_FlashReadBytes: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    435              addr         = (PARAM_START_ADDR + addr);
   \   0000000A   0xF104 0x54BE      ADD      R4,R4,#+398458880
   \   0000000E   0xF514 0x147F      ADDS     R4,R4,#+4177920
    436              
    437          	FLASH_Unlock();             					        // 解锁
   \   00000012   0x.... 0x....      BL       FLASH_Unlock
    438          
    439              u16 *p      = (u16 *)pbuf;
   \   00000016   0x002F             MOVS     R7,R5
    440              u16 size    = 0;
   \   00000018   0xF05F 0x0800      MOVS     R8,#+0
    441              
    442              for ( ; size < len ; size += 2 ) {
   \                     ??BSP_FlashReadBytes_0: (+1)
   \   0000001C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000020   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000022   0x45B0             CMP      R8,R6
   \   00000024   0xD206             BCS.N    ??BSP_FlashReadBytes_1
    443          		*p++     = *(vu16 *)addr;
   \   00000026   0x8820             LDRH     R0,[R4, #+0]
   \   00000028   0x8038             STRH     R0,[R7, #+0]
   \   0000002A   0x1CBF             ADDS     R7,R7,#+2
    444          		addr    += 2;	
   \   0000002C   0x1CA4             ADDS     R4,R4,#+2
    445          	}
   \   0000002E   0xF118 0x0802      ADDS     R8,R8,#+2
   \   00000032   0xE7F3             B.N      ??BSP_FlashReadBytes_0
    446              
    447          	FLASH_Lock();             					            // 上锁
   \                     ??BSP_FlashReadBytes_1: (+1)
   \   00000034   0x.... 0x....      BL       FLASH_Lock
    448              
    449              return len;
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    450          } 

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     FlashBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x17FFC000         DC32     0x17ffc000
    451          
    452          /*******************************************************************************
    453           * 				end of file
    454           *******************************************************************************/ 
    455          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   BSP_FLASH_ReadPage
      32   BSP_FLASH_WritePage
        32   -> FLASH_ProgramHalfWord
      24   BSP_FlashRead
        24   -> FLASH_Lock
        24   -> FLASH_Unlock
        24   -> FlashReadHalfWord
      24   BSP_FlashReadBytes
        24   -> FLASH_Lock
        24   -> FLASH_Unlock
      32   BSP_FlashWrite
        32   -> FLASH_ErasePage
        32   -> FLASH_Lock
        32   -> FLASH_Unlock
        32   -> FlashRead
        32   -> FlashWriteNoCheck
      48   BSP_FlashWriteBytes
        48   -> BSP_FLASH_ReadPage
        48   -> BSP_FLASH_WritePage
        48   -> FLASH_ErasePage
        48   -> FLASH_Lock
        48   -> FLASH_Unlock
        48   -> __aeabi_memcpy
      24   FlashRead
        24   -> FlashReadHalfWord
       0   FlashReadHalfWord
      24   FlashWriteNoCheck
        24   -> FLASH_ProgramHalfWord


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
      48  BSP_FLASH_ReadPage
     106  BSP_FLASH_WritePage
      46  BSP_FlashRead
      64  BSP_FlashReadBytes
     310  BSP_FlashWrite
     386  BSP_FlashWriteBytes
    1024  FlashBuf
      38  FlashRead
       4  FlashReadHalfWord
      42  FlashWriteNoCheck

 
 1 024 bytes in section .bss
 1 052 bytes in section .text
 
 1 052 bytes of CODE memory
 1 024 bytes of DATA memory

Errors: none
Warnings: 1
