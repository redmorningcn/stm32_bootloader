###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       28/Nov/2017  16:24:33
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\usart\usart.c
#    Command line =  
#        "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\usart\usart.c"
#        -D USE_STDPERIPH_DRIVER -lCN
#        "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List"
#        -o "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\IAR\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\crccheck\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\csnrprotocol\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAP_pragram\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\usart\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\ST\STM32\inc\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\CMSIS\CM3\CoreSupport\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List\usart.lst
#    Object file  =  
#        F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III -
#        副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj\usart.o
#
###############################################################################

F:\iar\Micrium_uC-Eval-STM32F107_uCOS-III - 副本\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\usart\usart.c
      1          #include "usart.h"	
      2          #include "stdarg.h"	
      3          
      4          ////////////////////////////////////////////////////////////////////////////////// 	 
      5          //如果使用ucos,则包括下面的头文件即可.
      6          #if SYSTEM_SUPPORT_OS
      7          #include "includes.h"					//ucos 使用	  
      8          
      9          #endif
     10          
     11          #include "stm32f10x_usart.h"            //ucos 使用	  
     12          #include "stm32f10x_gpio.h"            //ucos 使用	  
     13          
     14          
     15          //////////////////////////////////////////////////////////////////////////////////	 
     16          //本程序只供学习使用，未经作者许可，不得用于其它任何用途
     17          //ALIENTEK STM32F4探索者开发板
     18          //串口1初始化		   
     19          //正点原子@ALIENTEK
     20          //技术论坛:www.openedv.com
     21          //修改日期:2014/6/10
     22          //版本：V1.5
     23          //版权所有，盗版必究。
     24          //Copyright(C) 广州市星翼电子科技有限公司 2009-2019
     25          //All rights reserved
     26          //********************************************************************************
     27          //V1.3修改说明 
     28          //支持适应不同频率下的串口波特率设置.
     29          //加入了对printf的支持
     30          //增加了串口接收命令功能.
     31          //修正了printf第一个字符丢失的bug
     32          //V1.4修改说明
     33          //1,修改串口初始化IO的bug
     34          //2,修改了USART_RX_STA,使得串口最大接收字节数为2的14次方
     35          //3,增加了USART_REC_LEN,用于定义串口最大允许接收的字节数(不大于2的14次方)
     36          //4,修改了EN_USART1_RX的使能方式
     37          //V1.5修改说明
     38          //1,增加了对UCOSII的支持
     39          ////////////////////////////////////////////////////////////////////////////////// 	  
     40           
     41          void printfcom1(const char *format, ...);
     42          //
     43          ////////////////////////////////////////////////////////////////////
     44          ////加入以下代码,支持printf函数,而不需要选择use MicroLIB	  
     45          //#if 1
     46          //#pragma import(__use_no_semihosting)             
     47          ////标准库需要的支持函数                 
     48          //struct __FILE 
     49          //{ 
     50          //	int handle; 
     51          //}; 
     52          //
     53          //FILE __stdout;       
     54          ////定义_sys_exit()以避免使用半主机模式    
     55          //void _sys_exit(int x) 
     56          //{ 
     57          //	x = x; 
     58          //} 
     59          ////重定义fputc函数 
     60          //int fputc(int ch, FILE *f)
     61          //{ 	
     62          //	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
     63          //	USART1->DR = (u8) ch;      
     64          //	return ch;
     65          //}
     66          //#endif
     67           
     68          #if EN_USART1_RX   //如果使能了接收
     69          //串口1中断服务程序
     70          //注意,读取USARTx->SR能避免莫名其妙的错误   	

   \                                 In section .bss, align 4
     71          u8 USART_RX_BUF[USART_REC_LEN];     //接收缓冲,最大USART_REC_LEN个字节.
   \                     USART_RX_BUF:
   \   00000000                      DS8 200
     72          //接收状态
     73          //bit15，	接收完成标志
     74          //bit14，	接收到0x0d
     75          //bit13~0，	接收到的有效字节数目

   \                                 In section .bss, align 2
     76          u16 USART_RX_STA=0;       //接收状态标记	
   \                     USART_RX_STA:
   \   00000000                      DS8 2
     77          
     78          #define EnableUartSend()        GPIO_SetBits(GPIOE,GPIO_Pin_15)
     79          #define EnableUartRec()         GPIO_ResetBits(GPIOE,GPIO_Pin_15)
     80          int    GetSysBaseTick(void);
     81          
     82          
     83          #define MBREN3_GPIO_PIN        GPIO_Pin_15             /* PE.15 */
     84          #define MBREN3_GPIO_PORT       GPIOE
     85          #define MBREN3_GPIO_RCC        RCC_APB2Periph_GPIOE     
     86          

   \                                 In section .text, align 2, keep-with-next
     87          void EnUartContrlIO_Init(void)
     88          {    	 
   \                     EnUartContrlIO_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     89              GPIO_InitTypeDef  GPIO_InitStructure;
     90          
     91              RCC_APB2PeriphClockCmd(MBREN3_GPIO_RCC, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2040             MOVS     R0,#+64
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     92              GPIO_InitStructure.GPIO_Pin   = MBREN3_GPIO_PIN;
   \   0000000A   0xF44F 0x4000      MOV      R0,#+32768
   \   0000000E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     93              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000012   0x2003             MOVS     R0,#+3
   \   00000014   0xF88D 0x0002      STRB     R0,[SP, #+2]
     94              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
   \   00000018   0x2010             MOVS     R0,#+16
   \   0000001A   0xF88D 0x0003      STRB     R0,[SP, #+3]
     95              GPIO_Init(MBREN3_GPIO_PORT, &GPIO_InitStructure);
   \   0000001E   0x4669             MOV      R1,SP
   \   00000020   0x....             LDR.N    R0,??DataTable6  ;; 0x40011800
   \   00000022   0x.... 0x....      BL       GPIO_Init
     96          
     97              GPIO_ResetBits(MBREN3_GPIO_PORT, MBREN3_GPIO_PIN);  // 低电平接收使能  
   \   00000026   0xF44F 0x4100      MOV      R1,#+32768
   \   0000002A   0x....             LDR.N    R0,??DataTable6  ;; 0x40011800
   \   0000002C   0x.... 0x....      BL       GPIO_ResetBits
     98          }   
   \   00000030   0xBD01             POP      {R0,PC}          ;; return
     99          
    100          typedef struct  _stcmemcontrol 
    101          {
    102              u8      *pbuf;      //mem空间指针
    103              u16     buflen;     
    104              u16     pwrite;     //写伪指针
    105              u16     pread;      //读伪指针
    106              u16     pwriteflg;   //最后标识时，写指针位置。
    107              u16     flg;        //标记，b[0] = 1标记， [
    108          }stcmemcontrol;
    109          

   \                                 In section .bss, align 4
    110          u8      uartbuf[1024];
   \                     uartbuf:
   \   00000000                      DS8 1024

   \                                 In section .bss, align 4
    111          stcmemcontrol   g_uart;
   \                     g_uart:
   \   00000000                      DS8 16
    112          extern  uint64_t g_systime;
    113          

   \                                 In section .text, align 2, keep-with-next
    114          void    initmemcontrol(stcmemcontrol *memcontrl, u8 *buf,u32 len)
    115          {
    116              memcontrl->flg      = 0;
   \                     initmemcontrol: (+1)
   \   00000000   0x2300             MOVS     R3,#+0
   \   00000002   0x8183             STRH     R3,[R0, #+12]
    117              memcontrl->pbuf     = buf;
   \   00000004   0x6001             STR      R1,[R0, #+0]
    118              memcontrl->pread    = 0;
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x8103             STRH     R3,[R0, #+8]
    119              memcontrl->pwrite   = 0;
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x80C3             STRH     R3,[R0, #+6]
    120              memcontrl->pwriteflg=0;
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x8143             STRH     R3,[R0, #+10]
    121              memcontrl->buflen   = len;
   \   00000012   0x8082             STRH     R2,[R0, #+4]
    122          }
   \   00000014   0x4770             BX       LR               ;; return
    123          void USART3_IRQHandler(void);                	//串口3中断服务程序
    124          
    125          //初始化IO 串口1 
    126          //bound:波特率

   \                                 In section .text, align 2, keep-with-next
    127          void uart_init(u32 baud){
   \                     uart_init: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
    128             //GPIO端口设置
    129              
    130              GPIO_InitTypeDef GPIO_InitStructure;
    131          	USART_InitTypeDef USART_InitStructure;
    132          	NVIC_InitTypeDef NVIC_InitStructure;
    133             
    134              INT16U            BSP_INT_ID_USARTx;
    135              USART_TypeDef*    USARTx;
    136              CPU_FNCT_VOID     USARTx_RxTxISRHandler;
    137              
    138              USARTx                    = USART3;
   \   00000006   0x....             LDR.N    R0,??DataTable6_1  ;; 0x40004800
   \   00000008   0x0006             MOVS     R6,R0
    139              BSP_INT_ID_USARTx         = BSP_INT_ID_USART3;
   \   0000000A   0x2027             MOVS     R0,#+39
   \   0000000C   0x0005             MOVS     R5,R0
    140              USARTx_RxTxISRHandler     = USART3_IRQHandler;
   \   0000000E   0x.... 0x....      ADR.W    R0,USART3_IRQHandler
   \   00000012   0x0007             MOVS     R7,R0
    141              /* Enable USART3 clock */
    142              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xF45F 0x2080      MOVS     R0,#+262144
   \   0000001A   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    143              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x2008             MOVS     R0,#+8
   \   00000022   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    144          
    145              /* Configure USART1 Rx (PB.11) as input floating */
    146              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
   \   00000026   0xF44F 0x6000      MOV      R0,#+2048
   \   0000002A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    147              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   0000002E   0x2004             MOVS     R0,#+4
   \   00000030   0xF88D 0x0003      STRB     R0,[SP, #+3]
    148              GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000034   0x4669             MOV      R1,SP
   \   00000036   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40010c00
   \   00000038   0x.... 0x....      BL       GPIO_Init
    149              
    150              /* Configure USART1 Tx (PB.10) as alternate function push-pull */
    151              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   0000003C   0xF44F 0x6080      MOV      R0,#+1024
   \   00000040   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    152              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000044   0x2003             MOVS     R0,#+3
   \   00000046   0xF88D 0x0002      STRB     R0,[SP, #+2]
    153              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   0000004A   0x2018             MOVS     R0,#+24
   \   0000004C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    154              GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000050   0x4669             MOV      R1,SP
   \   00000052   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40010c00
   \   00000054   0x.... 0x....      BL       GPIO_Init
    155          
    156              /***********************************************
    157              * 描述： configuration
    158              */
    159              USART_InitStructure.USART_BaudRate              = baud;
   \   00000058   0x9401             STR      R4,[SP, #+4]
    160              USART_InitStructure.USART_WordLength            = USART_WordLength_8b;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    161              USART_InitStructure.USART_StopBits              = USART_StopBits_1;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    162              USART_InitStructure.USART_Parity                = USART_Parity_No;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    163              USART_InitStructure.USART_HardwareFlowControl   = USART_HardwareFlowControl_None;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    164              USART_InitStructure.USART_Mode                  = USART_Mode_Rx | USART_Mode_Tx;
   \   00000072   0x200C             MOVS     R0,#+12
   \   00000074   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    165              
    166              /***********************************************
    167              * 描述： 
    168              */
    169              USART_DeInit(USARTx);
   \   00000078   0x0030             MOVS     R0,R6
   \   0000007A   0x.... 0x....      BL       USART_DeInit
    170              USART_Init(USARTx, &USART_InitStructure);
   \   0000007E   0xA901             ADD      R1,SP,#+4
   \   00000080   0x0030             MOVS     R0,R6
   \   00000082   0x.... 0x....      BL       USART_Init
    171              
    172              /***********************************************
    173              * 描述： 
    174              */
    175              //if ( port_nbr != 3 )
    176              USART_ITConfig(USARTx, USART_IT_RXNE, ENABLE);
   \   00000086   0x2201             MOVS     R2,#+1
   \   00000088   0xF240 0x5125      MOVW     R1,#+1317
   \   0000008C   0x0030             MOVS     R0,R6
   \   0000008E   0x.... 0x....      BL       USART_ITConfig
    177              USART_ITConfig(USARTx, USART_IT_TXE, DISABLE);
   \   00000092   0x2200             MOVS     R2,#+0
   \   00000094   0xF240 0x7127      MOVW     R1,#+1831
   \   00000098   0x0030             MOVS     R0,R6
   \   0000009A   0x.... 0x....      BL       USART_ITConfig
    178              //USART_ITConfig(USARTx, USART_IT_IDLE, ENABLE);
    179              
    180              /***********************************************
    181              * 描述： 
    182              */
    183              USART_ClearFlag(USARTx,USART_FLAG_TXE);
   \   0000009E   0x2180             MOVS     R1,#+128
   \   000000A0   0x0030             MOVS     R0,R6
   \   000000A2   0x.... 0x....      BL       USART_ClearFlag
    184              USART_ClearFlag(USARTx,USART_FLAG_RXNE);
   \   000000A6   0x2120             MOVS     R1,#+32
   \   000000A8   0x0030             MOVS     R0,R6
   \   000000AA   0x.... 0x....      BL       USART_ClearFlag
    185              //USART_ClearFlag(USARTx,USART_FLAG_IDLE);      
    186              
    187              /***********************************************
    188              * 描述： 
    189              */
    190              USART_Cmd(USARTx, ENABLE);
   \   000000AE   0x2101             MOVS     R1,#+1
   \   000000B0   0x0030             MOVS     R0,R6
   \   000000B2   0x.... 0x....      BL       USART_Cmd
    191              
    192              /***********************************************
    193              * 描述： 
    194              */
    195              BSP_IntVectSet(BSP_INT_ID_USARTx, USARTx_RxTxISRHandler);
   \   000000B6   0x0039             MOVS     R1,R7
   \   000000B8   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000BA   0x0028             MOVS     R0,R5
   \   000000BC   0x.... 0x....      BL       BSP_IntVectSet
    196              BSP_IntEn(BSP_INT_ID_USARTx);
   \   000000C0   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000C2   0x0028             MOVS     R0,R5
   \   000000C4   0x.... 0x....      BL       BSP_IntEn
    197          	
    198              
    199              EnUartContrlIO_Init();
   \   000000C8   0x.... 0x....      BL       EnUartContrlIO_Init
    200              initmemcontrol((stcmemcontrol  *)&g_uart,uartbuf,sizeof(uartbuf));           //3?ê??ˉ′??ú?óê??o′?
   \   000000CC   0xF44F 0x6280      MOV      R2,#+1024
   \   000000D0   0x....             LDR.N    R1,??DataTable6_3
   \   000000D2   0x....             LDR.N    R0,??DataTable6_4
   \   000000D4   0x.... 0x....      BL       initmemcontrol
    201          }
   \   000000D8   0xB005             ADD      SP,SP,#+20
   \   000000DA   0xBDF0             POP      {R4-R7,PC}       ;; return
    202          
    203          

   \                                 In section .bss, align 8
    204          uint64_t l_uartrectime = 0;                 //串口接受时间
   \                     l_uartrectime:
   \   00000000                      DS8 8
    205          
    206          #define REC_FLG     1                       /*接收标识*/
    207          
    208          #define END_FLG     0                       /*结束标识*/
    209          
    210          

   \                                 In section .text, align 4, keep-with-next
    211          void USART3_IRQHandler(void)                	//串口3中断服务程序
    212          {
   \                     USART3_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    213          	u8 Res;
    214          #if SYSTEM_SUPPORT_OS 		//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.
    215          	OSIntEnter();    
    216          #endif
    217              
    218              l_uartrectime =  GetSysBaseTick();
   \   00000002   0x.... 0x....      BL       GetSysBaseTick
   \   00000006   0x17C1             ASRS     R1,R0,#+31
   \   00000008   0x....             LDR.N    R2,??DataTable6_5
   \   0000000A   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
    219          
    220              g_uart.flg |= (0x01<< REC_FLG);
   \   0000000E   0x....             LDR.N    R0,??DataTable6_4
   \   00000010   0x8980             LDRH     R0,[R0, #+12]
   \   00000012   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000016   0x....             LDR.N    R1,??DataTable6_4
   \   00000018   0x8188             STRH     R0,[R1, #+12]
    221              
    222          	if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)   //接收中断(接收到的数据必须是0x0d 0x0a结尾)
   \   0000001A   0xF240 0x5125      MOVW     R1,#+1317
   \   0000001E   0x....             LDR.N    R0,??DataTable6_1  ;; 0x40004800
   \   00000020   0x.... 0x....      BL       USART_GetITStatus
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD012             BEQ.N    ??USART3_IRQHandler_0
    223          	{
    224                  Res =USART_ReceiveData(USART3);//(USART1->DR);	    //读取接收到的数据
   \   00000028   0x....             LDR.N    R0,??DataTable6_1  ;; 0x40004800
   \   0000002A   0x.... 0x....      BL       USART_ReceiveData
   \   0000002E   0x0004             MOVS     R4,R0
    225                  //printfcom1("%c",Res);
    226                  uartbuf[ g_uart.pwrite ] =  Res;         //数据保存
   \   00000030   0x....             LDR.N    R0,??DataTable6_3
   \   00000032   0x....             LDR.N    R1,??DataTable6_4
   \   00000034   0x88C9             LDRH     R1,[R1, #+6]
   \   00000036   0x540C             STRB     R4,[R1, R0]
    227          
    228                  g_uart.pwrite = (g_uart.pwrite + 1)%g_uart.buflen;
   \   00000038   0x....             LDR.N    R0,??DataTable6_4
   \   0000003A   0x88C0             LDRH     R0,[R0, #+6]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x....             LDR.N    R1,??DataTable6_4
   \   00000040   0x8889             LDRH     R1,[R1, #+4]
   \   00000042   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000046   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   0000004A   0x....             LDR.N    R1,??DataTable6_4
   \   0000004C   0x80C8             STRH     R0,[R1, #+6]
    229                  
    230              } 
    231          #if SYSTEM_SUPPORT_OS 	//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.
    232          	OSIntExit();  											 
    233          #endif
    234          } 
   \                     ??USART3_IRQHandler_0: (+1)
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
    235          #endif	
    236          
    237          

   \                                 In section .text, align 2, keep-with-next
    238          void    HoldUartRecSta(void)                                        //维护串口状态
    239          {
   \                     HoldUartRecSta: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    240              static  uint64_t systime;
    241              systime = GetSysBaseTick();
   \   00000002   0x.... 0x....      BL       GetSysBaseTick
   \   00000006   0x17C1             ASRS     R1,R0,#+31
   \   00000008   0x....             LDR.N    R2,??DataTable6_6
   \   0000000A   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
    242              //if(systime >  (l_uartrectime + (84000000/9)/100))         //10ms无数据，认为通讯错误
    243              if(systime >  (l_uartrectime + 10))         //10ms无数据，认为通讯错误
   \   0000000E   0x....             LDR.N    R0,??DataTable6_5
   \   00000010   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   00000014   0xF112 0x000A      ADDS     R0,R2,#+10
   \   00000018   0xF153 0x0100      ADCS     R1,R3,#+0
   \   0000001C   0x....             LDR.N    R2,??DataTable6_6
   \   0000001E   0xE9D2 0x4500      LDRD     R4,R5,[R2, #+0]
   \   00000022   0x42A9             CMP      R1,R5
   \   00000024   0xD826             BHI.N    ??HoldUartRecSta_0
   \   00000026   0xD301             BCC.N    ??HoldUartRecSta_1
   \   00000028   0x42A0             CMP      R0,R4
   \   0000002A   0xD223             BCS.N    ??HoldUartRecSta_0
    244              {
    245                  if(     (  (g_uart.flg &(0x01 << END_FLG)) == 0 &&  (g_uart.flg &(0x01 << REC_FLG)))     //超时
    246                      ||  (  (g_uart.pwrite < g_uart.pread)       &&  (g_uart.pwrite+10 == g_uart.pread))  //写满  差10空间 
    247                    )   
   \                     ??HoldUartRecSta_1: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable6_4
   \   0000002E   0x7B00             LDRB     R0,[R0, #+12]
   \   00000030   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000034   0x2802             CMP      R0,#+2
   \   00000036   0xD00C             BEQ.N    ??HoldUartRecSta_2
   \   00000038   0x....             LDR.N    R0,??DataTable6_4
   \   0000003A   0x88C0             LDRH     R0,[R0, #+6]
   \   0000003C   0x....             LDR.N    R1,??DataTable6_4
   \   0000003E   0x8909             LDRH     R1,[R1, #+8]
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD217             BCS.N    ??HoldUartRecSta_0
   \   00000044   0x....             LDR.N    R0,??DataTable6_4
   \   00000046   0x88C0             LDRH     R0,[R0, #+6]
   \   00000048   0x300A             ADDS     R0,R0,#+10
   \   0000004A   0x....             LDR.N    R1,??DataTable6_4
   \   0000004C   0x8909             LDRH     R1,[R1, #+8]
   \   0000004E   0x4288             CMP      R0,R1
   \   00000050   0xD110             BNE.N    ??HoldUartRecSta_0
    248                  {
    249                      g_uart.flg   |= (0x01 << END_FLG);           //数据接收结束
   \                     ??HoldUartRecSta_2: (+1)
   \   00000052   0x....             LDR.N    R0,??DataTable6_4
   \   00000054   0x8980             LDRH     R0,[R0, #+12]
   \   00000056   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000005A   0x....             LDR.N    R1,??DataTable6_4
   \   0000005C   0x8188             STRH     R0,[R1, #+12]
    250                      g_uart.flg   &= ~(0x01 << REC_FLG);          //清数据接收
   \   0000005E   0x....             LDR.N    R0,??DataTable6_4
   \   00000060   0x8980             LDRH     R0,[R0, #+12]
   \   00000062   0xF64F 0x71FD      MOVW     R1,#+65533
   \   00000066   0x4008             ANDS     R0,R1,R0
   \   00000068   0x....             LDR.N    R1,??DataTable6_4
   \   0000006A   0x8188             STRH     R0,[R1, #+12]
    251          
    252                      g_uart.pwriteflg = g_uart.pwrite; //标识区结束时标识
   \   0000006C   0x....             LDR.N    R0,??DataTable6_4
   \   0000006E   0x88C0             LDRH     R0,[R0, #+6]
   \   00000070   0x....             LDR.N    R1,??DataTable6_4
   \   00000072   0x8148             STRH     R0,[R1, #+10]
    253                      //printfcom1("\r\n pwrite %d",g_uart.pwrite);
    254                  }
    255              }
    256          }    
   \                     ??HoldUartRecSta_0: (+1)
   \   00000074   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .bss, align 8
   \                     ??systime:
   \   00000000                      DS8 8
    257          //
    258          //uint8	GetFramRecEndFlg(void)
    259          //{
    260          ////	return GetCOM1EndFlg(); 
    261          //    return (g_uart.flg   & (0x01 << END_FLG)); 
    262          //}
    263          //
    264          ////???óê?íê3é±ê??  ??èe
    265          //void	ClearFramRecEndFlg(void)
    266          //{
    267          ////	ClearCOM1EndFlg();  
    268          //    g_uart.flg   &= ~(0x01 << END_FLG);          //清数据接收
    269          //}
    270          
    271          
    272          

   \                                 In section .text, align 2, keep-with-next
    273          u32 ReadUartBuf(u8 *buf,u32 len)        //从串口缓存区读数据
    274          {
   \                     ReadUartBuf: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0002             MOVS     R2,R0
    275              if((g_uart.flg & (0x01<< END_FLG)) == 0)   //无结束标识，退出
   \   00000004   0x....             LDR.N    R0,??DataTable6_4
   \   00000006   0x7B00             LDRB     R0,[R0, #+12]
   \   00000008   0x07C0             LSLS     R0,R0,#+31
   \   0000000A   0xD401             BMI.N    ??ReadUartBuf_0
    276                  return 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE036             B.N      ??ReadUartBuf_1
    277              
    278              g_uart.flg &= ~(0x01<< END_FLG);           //清结束标识
   \                     ??ReadUartBuf_0: (+1)
   \   00000010   0x....             LDR.N    R0,??DataTable6_4
   \   00000012   0x8980             LDRH     R0,[R0, #+12]
   \   00000014   0xF64F 0x73FE      MOVW     R3,#+65534
   \   00000018   0x4018             ANDS     R0,R3,R0
   \   0000001A   0x....             LDR.N    R3,??DataTable6_4
   \   0000001C   0x8198             STRH     R0,[R3, #+12]
    279              
    280              u32 noreadlen  = (g_uart.pwriteflg + g_uart.buflen - g_uart.pread) % g_uart.buflen; //计算接受缓冲区的数据为读长度
   \   0000001E   0x....             LDR.N    R0,??DataTable6_4
   \   00000020   0x8940             LDRH     R0,[R0, #+10]
   \   00000022   0x....             LDR.N    R3,??DataTable6_4
   \   00000024   0x889B             LDRH     R3,[R3, #+4]
   \   00000026   0x1818             ADDS     R0,R3,R0
   \   00000028   0x....             LDR.N    R3,??DataTable6_4
   \   0000002A   0x891B             LDRH     R3,[R3, #+8]
   \   0000002C   0x1AC0             SUBS     R0,R0,R3
   \   0000002E   0x....             LDR.N    R3,??DataTable6_4
   \   00000030   0x889B             LDRH     R3,[R3, #+4]
   \   00000032   0xFB90 0xF4F3      SDIV     R4,R0,R3
   \   00000036   0xFB03 0x0314      MLS      R3,R3,R4,R0
    281              
    282              u32 readlen    = (noreadlen>len)?len:noreadlen;    //取读数长度
   \   0000003A   0x4299             CMP      R1,R3
   \   0000003C   0xD201             BCS.N    ??ReadUartBuf_2
   \   0000003E   0x0008             MOVS     R0,R1
   \   00000040   0xE000             B.N      ??ReadUartBuf_3
   \                     ??ReadUartBuf_2: (+1)
   \   00000042   0x0018             MOVS     R0,R3
    283          
    284              for(u32 i=0;i<readlen;i++)
   \                     ??ReadUartBuf_3: (+1)
   \   00000044   0x2400             MOVS     R4,#+0
   \                     ??ReadUartBuf_4: (+1)
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xD20E             BCS.N    ??ReadUartBuf_5
    285                  buf[i] = g_uart.pbuf[(g_uart.pread + i)%g_uart.buflen];
   \   0000004A   0x....             LDR.N    R5,??DataTable6_4
   \   0000004C   0x892D             LDRH     R5,[R5, #+8]
   \   0000004E   0x1965             ADDS     R5,R4,R5
   \   00000050   0x....             LDR.N    R6,??DataTable6_4
   \   00000052   0x88B6             LDRH     R6,[R6, #+4]
   \   00000054   0xFBB5 0xF7F6      UDIV     R7,R5,R6
   \   00000058   0xFB06 0x5517      MLS      R5,R6,R7,R5
   \   0000005C   0x....             LDR.N    R6,??DataTable6_4
   \   0000005E   0x6836             LDR      R6,[R6, #+0]
   \   00000060   0x5DAD             LDRB     R5,[R5, R6]
   \   00000062   0x54A5             STRB     R5,[R4, R2]
   \   00000064   0x1C64             ADDS     R4,R4,#+1
   \   00000066   0xE7EE             B.N      ??ReadUartBuf_4
    286              
    287              g_uart.pread = (g_uart.pread + readlen)%g_uart.buflen;
   \                     ??ReadUartBuf_5: (+1)
   \   00000068   0x....             LDR.N    R4,??DataTable6_4
   \   0000006A   0x8924             LDRH     R4,[R4, #+8]
   \   0000006C   0x1904             ADDS     R4,R0,R4
   \   0000006E   0x....             LDR.N    R5,??DataTable6_4
   \   00000070   0x88AD             LDRH     R5,[R5, #+4]
   \   00000072   0xFBB4 0xF6F5      UDIV     R6,R4,R5
   \   00000076   0xFB05 0x4416      MLS      R4,R5,R6,R4
   \   0000007A   0x....             LDR.N    R5,??DataTable6_4
   \   0000007C   0x812C             STRH     R4,[R5, #+8]
    288                  
    289              //printfcom1("\r\n readlen %d",readlen);
    290              
    291              return  readlen;                            //返回读取的数据长度
   \                     ??ReadUartBuf_1: (+1)
   \   0000007E   0xBCF0             POP      {R4-R7}
   \   00000080   0x4770             BX       LR               ;; return
    292          }
    293           

   \                                 In section .text, align 2, keep-with-next
    294          u32 SendDataCom1(u8 *buf,u32 len)
    295          {
   \                     SendDataCom1: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    296              EnableUartSend();       //IO端口变为发送端口
   \   00000006   0xF44F 0x4100      MOV      R1,#+32768
   \   0000000A   0x....             LDR.N    R0,??DataTable6  ;; 0x40011800
   \   0000000C   0x.... 0x....      BL       GPIO_SetBits
    297          
    298              for(u32 i = 0;i < len;i++)
   \   00000010   0x2600             MOVS     R6,#+0
   \                     ??SendDataCom1_0: (+1)
   \   00000012   0x42AE             CMP      R6,R5
   \   00000014   0xD212             BCS.N    ??SendDataCom1_1
    299              {
    300                  uint32  times = 10000;
   \   00000016   0xF242 0x7710      MOVW     R7,#+10000
    301                  USART_SendData(USART3,buf[i]);
   \   0000001A   0x5D31             LDRB     R1,[R6, R4]
   \   0000001C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001E   0x....             LDR.N    R0,??DataTable6_1  ;; 0x40004800
   \   00000020   0x.... 0x....      BL       USART_SendData
    302                  
    303                  while(  USART_GetFlagStatus(USART3,USART_FLAG_TC)!=SET
    304                      &&  times-- );  //增加退出机制
   \                     ??SendDataCom1_2: (+1)
   \   00000024   0x2140             MOVS     R1,#+64
   \   00000026   0x....             LDR.N    R0,??DataTable6_1  ;; 0x40004800
   \   00000028   0x.... 0x....      BL       USART_GetFlagStatus
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD003             BEQ.N    ??SendDataCom1_3
   \   00000030   0x0038             MOVS     R0,R7
   \   00000032   0x1E47             SUBS     R7,R0,#+1
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD1F5             BNE.N    ??SendDataCom1_2
    305              }
   \                     ??SendDataCom1_3: (+1)
   \   00000038   0x1C76             ADDS     R6,R6,#+1
   \   0000003A   0xE7EA             B.N      ??SendDataCom1_0
    306              
    307              EnableUartRec();        //IO端口变为接受端口
   \                     ??SendDataCom1_1: (+1)
   \   0000003C   0xF44F 0x4100      MOV      R1,#+32768
   \   00000040   0x....             LDR.N    R0,??DataTable6  ;; 0x40011800
   \   00000042   0x.... 0x....      BL       GPIO_ResetBits
    308          
    309              return  len;
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    310          }
    311          

   \                                 In section .text, align 2, keep-with-next
    312          void printfcom1(const char *format, ...) 
    313          { 
   \                     printfcom1: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB530             PUSH     {R4,R5,LR}
   \   00000004   0xB0C0             SUB      SP,SP,#+256
   \   00000006   0x0004             MOVS     R4,R0
    314             va_list  argptr;
    315          //   uint32   cnt;
    316             char     a[255];
    317             
    318             strlen(format);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       strlen
    319             if(strlen(format) > (sizeof(a) - 55))
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       strlen
   \   00000014   0x28C9             CMP      R0,#+201
   \   00000016   0xD20D             BCS.N    ??printfcom1_0
    320             {
    321          //        return FALSE;
    322          		return	;
    323             }
    324             va_start(argptr, format);
   \                     ??printfcom1_1: (+1)
   \   00000018   0xA843             ADD      R0,SP,#+268
   \   0000001A   0x0005             MOVS     R5,R0
    325             
    326          //   cnt = vsprintf(a, format, argptr);
    327             vsprintf(a, format, argptr);
   \   0000001C   0x002A             MOVS     R2,R5
   \   0000001E   0x0021             MOVS     R1,R4
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x.... 0x....      BL       vsprintf
    328             
    329             va_end(argptr);
    330             
    331             SendDataCom1((u8 *)a,strlen(a));
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x.... 0x....      BL       strlen
   \   0000002C   0x0001             MOVS     R1,R0
   \   0000002E   0x4668             MOV      R0,SP
   \   00000030   0x.... 0x....      BL       SendDataCom1
    332          //   return(cnt);
    333          }
   \                     ??printfcom1_0: (+1)
   \   00000034   0xB040             ADD      SP,SP,#+256
   \   00000036   0xBC30             POP      {R4,R5}
   \   00000038   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
    334          

   \                                 In section .text, align 2, keep-with-next
    335          void    TestUart(void)
    336          {
   \                     TestUart: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB0C0             SUB      SP,SP,#+256
    337              printfcom1("\r\nstart\r\n");
   \   00000004   0x....             LDR.N    R0,??DataTable6_7
   \   00000006   0x.... 0x....      BL       printfcom1
    338              while(1)
    339              {
    340                  u32 len = 5;
   \                     ??TestUart_0: (+1)
   \   0000000A   0x2405             MOVS     R4,#+5
    341                  u8 buf[256]={0,1,2,3,4,5};
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x....             LDR.N    R1,??DataTable6_8
   \   00000010   0xF44F 0x7280      MOV      R2,#+256
   \   00000014   0x.... 0x....      BL       __aeabi_memcpy4
    342          
    343                  HoldUartRecSta();
   \   00000018   0x.... 0x....      BL       HoldUartRecSta
    344                  
    345                  len = ReadUartBuf(buf,sizeof(buf));
   \   0000001C   0xF44F 0x7180      MOV      R1,#+256
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x.... 0x....      BL       ReadUartBuf
   \   00000026   0x0004             MOVS     R4,R0
    346                  if( len )
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD0EE             BEQ.N    ??TestUart_0
    347                      SendDataCom1(buf,len);
   \   0000002C   0x0021             MOVS     R1,R4
   \   0000002E   0x4668             MOV      R0,SP
   \   00000030   0x.... 0x....      BL       SendDataCom1
   \   00000034   0xE7E9             B.N      ??TestUart_0
    348                  
    349              }
    350          }
    351                          
    352          

   \                                 In section .text, align 2, keep-with-next
    353          uint8	GetFramRecEndFlgIAP(void)
    354          {
   \                     GetFramRecEndFlgIAP: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    355          //	return GetCOM1EndFlg(); 
    356              return ((GetCOM2EndFlg())|(GetCOM3EndFlg())); 
   \   00000002   0x.... 0x....      BL       GetCOM2EndFlg
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x.... 0x....      BL       GetCOM3EndFlg
   \   0000000C   0x4320             ORRS     R0,R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    357          }
    358          
    359          //???óê?íê3é±ê??  ??èe

   \                                 In section .text, align 2, keep-with-next
    360          void	ClearFramRecEndFlgIAP(void)
    361          {
   \                     ClearFramRecEndFlgIAP: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    362          //	ClearCOM1EndFlg();  
    363          		ClearCOM2EndFlg();  
   \   00000002   0x.... 0x....      BL       ClearCOM2EndFlg
    364          		ClearCOM3EndFlg();  
   \   00000006   0x.... 0x....      BL       ClearCOM3EndFlg
    365          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    366          

   \                                 In section .text, align 2, keep-with-next
    367          uint16	ReadRs485DataIAP(uint8 *Buf)
    368          {
   \                     ReadRs485DataIAP: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    369          	uint16	len = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    370          	 
    371          	if(GetCOM2EndFlg())
   \   00000006   0x.... 0x....      BL       GetCOM2EndFlg
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD008             BEQ.N    ??ReadRs485DataIAP_0
    372          	{
    373          		len = ReadCOM2(Buf,256); 
   \   0000000E   0xF44F 0x7180      MOV      R1,#+256
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       ReadCOM2
   \   00000018   0x0005             MOVS     R5,R0
    374          		return	len; 
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   0xE00C             B.N      ??ReadRs485DataIAP_1
    375          	}
    376          	
    377          	if(GetCOM3EndFlg())
   \                     ??ReadRs485DataIAP_0: (+1)
   \   00000020   0x.... 0x....      BL       GetCOM3EndFlg
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD008             BEQ.N    ??ReadRs485DataIAP_2
    378          	{
    379          		len = ReadCOM3(Buf,256);
   \   00000028   0xF44F 0x7180      MOV      R1,#+256
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       ReadCOM3
   \   00000032   0x0005             MOVS     R5,R0
    380          		return	len;  
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000038   0xE7FF             B.N      ??ReadRs485DataIAP_1
    381          	}	
    382          }
   \                     ??ReadRs485DataIAP_2: (+1)
   \                     ??ReadRs485DataIAP_1: (+1)
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x40011800         DC32     0x40011800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     uartbuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     g_uart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     l_uartrectime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     ??systime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x0D 0x0A          DC8 "\015\012start\015\012"
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x0D    
   \              0x0A 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x00 0x01          DC8 0, 1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x02 0x03    
   \              0x04 0x05    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000017   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000002E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000045   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000005C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000073   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000008A   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000A1   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000B8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000CF   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000E6   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000FD   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    383          
    384          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ClearFramRecEndFlgIAP
         8   -> ClearCOM2EndFlg
         8   -> ClearCOM3EndFlg
       8   EnUartContrlIO_Init
         8   -> GPIO_Init
         8   -> GPIO_ResetBits
         8   -> RCC_APB2PeriphClockCmd
       8   GetFramRecEndFlgIAP
         8   -> GetCOM2EndFlg
         8   -> GetCOM3EndFlg
      16   HoldUartRecSta
        16   -> GetSysBaseTick
      16   ReadRs485DataIAP
        16   -> GetCOM2EndFlg
        16   -> GetCOM3EndFlg
        16   -> ReadCOM2
        16   -> ReadCOM3
      16   ReadUartBuf
      24   SendDataCom1
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> USART_GetFlagStatus
        24   -> USART_SendData
     264   TestUart
       264   -> HoldUartRecSta
       264   -> ReadUartBuf
       264   -> SendDataCom1
       264   -> __aeabi_memcpy4
       264   -> printfcom1
       8   USART3_IRQHandler
         8   -> GetSysBaseTick
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
       0   initmemcontrol
     280   printfcom1
       280   -> SendDataCom1
       280   -> strlen
       280   -> vsprintf
      40   uart_init
        40   -> BSP_IntEn
        40   -> BSP_IntVectSet
        40   -> EnUartContrlIO_Init
        40   -> GPIO_Init
        40   -> RCC_APB1PeriphClockCmd
        40   -> RCC_APB2PeriphClockCmd
        40   -> USART_ClearFlag
        40   -> USART_Cmd
        40   -> USART_DeInit
        40   -> USART_ITConfig
        40   -> USART_Init
        40   -> initmemcontrol


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
      12  ?_0
     256  ?_1
      12  ClearFramRecEndFlgIAP
      50  EnUartContrlIO_Init
      18  GetFramRecEndFlgIAP
     118  HoldUartRecSta
      60  ReadRs485DataIAP
     130  ReadUartBuf
      74  SendDataCom1
      54  TestUart
      80  USART3_IRQHandler
     200  USART_RX_BUF
       2  USART_RX_STA
      16  g_uart
      22  initmemcontrol
       8  l_uartrectime
      60  printfcom1
       8  systime
     220  uart_init
    1024  uartbuf

 
 1 258 bytes in section .bss
   268 bytes in section .rodata
   934 bytes in section .text
 
   934 bytes of CODE  memory
   268 bytes of CONST memory
 1 258 bytes of DATA  memory

Errors: none
Warnings: 11
